var _excluded = ["fullNameSuffix"],
  _excluded2 = ["labels"],
  _excluded3 = ["fullNameSuffix", "suites", "duration", "retries"],
  _excluded4 = ["id"],
  _excluded5 = ["id", "stop"],
  _excluded6 = ["id"],
  _excluded7 = ["resultsDir", "videoOnFailOnly"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { ContentType, Stage, Status } from "allure-js-commons";
import { ReporterRuntime, createDefaultWriter, getEnvironmentLabels, getFrameworkLabel, getHostLabel, getLanguageLabel, getPackageLabel, getPosixPath, getProjectRoot, getRelativePath, getSuiteLabels, getThreadLabel, parseTestPlan } from "allure-js-commons/sdk/reporter";
import { DEFAULT_RUNTIME_CONFIG, last } from "./utils.js";
var _endAllSpecs = /*#__PURE__*/new WeakMap();
var _applyAllureCypressMessages = /*#__PURE__*/new WeakMap();
var _startRun = /*#__PURE__*/new WeakMap();
var _startSuite = /*#__PURE__*/new WeakMap();
var _pushNewSuiteScope = /*#__PURE__*/new WeakMap();
var _stopSuite = /*#__PURE__*/new WeakMap();
var _writeLastSuiteScope = /*#__PURE__*/new WeakMap();
var _startHook = /*#__PURE__*/new WeakMap();
var _stopHook = /*#__PURE__*/new WeakMap();
var _startTest = /*#__PURE__*/new WeakMap();
var _addNewTestResult = /*#__PURE__*/new WeakMap();
var _failHookAndTest = /*#__PURE__*/new WeakMap();
var _passTest = /*#__PURE__*/new WeakMap();
var _skipTest = /*#__PURE__*/new WeakMap();
var _addSkippedTest = /*#__PURE__*/new WeakMap();
var _stopTest = /*#__PURE__*/new WeakMap();
var _stopExistingTestResult = /*#__PURE__*/new WeakMap();
var _fixTestStepStops = /*#__PURE__*/new WeakMap();
var _fixFixtureStepStops = /*#__PURE__*/new WeakMap();
var _fixStepStops = /*#__PURE__*/new WeakMap();
var _startStep = /*#__PURE__*/new WeakMap();
var _stopStep = /*#__PURE__*/new WeakMap();
var _finalizeStep = /*#__PURE__*/new WeakMap();
var _applyRuntimeApiMessages = /*#__PURE__*/new WeakMap();
var _emitPreviousTestScope = /*#__PURE__*/new WeakMap();
var _resolveRootUuid = /*#__PURE__*/new WeakMap();
var _attachSpecVideo = /*#__PURE__*/new WeakMap();
var _emitRemainingScopes = /*#__PURE__*/new WeakMap();
var _initializeSpecContext = /*#__PURE__*/new WeakMap();
export class AllureCypress {
  constructor() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _defineProperty(this, "allureRuntime", void 0);
    _defineProperty(this, "specContextByAbsolutePath", new Map());
    _defineProperty(this, "videoOnFailOnly", false);
    _defineProperty(this, "attachToCypress", on => {
      on("task", {
        reportAllureCypressSpecMessages: args => {
          _classPrivateFieldGet(_applyAllureCypressMessages, this).call(this, args);
          return null;
        },
        reportFinalAllureCypressSpecMessages: args => {
          _classPrivateFieldGet(_applyAllureCypressMessages, this).call(this, args);
          if (args.isInteractive) {
            // In non-interactive mode the spec is ended via the 'after:spec' event instead
            // to get the spec's video.
            this.endSpec(args.absolutePath);
          }
          return null;
        }
      });

      // Emits the remaining fixtures and writes the video of the spec.
      // In interactive mode it's invoked through the `reportFinalAllureCypressSpecMessages` task.
      on("after:spec", this.onAfterSpec);

      // Emits the categories and env info. Doesn't work in interactive mode unless
      // `experimentalInteractiveRunEvents` is set.
      on("after:run", this.onAfterRun);
    });
    /**
     * Forward the `after:spec` event into Allure Cypress using this function if
     * you need to define your own handler or combine Allure Cypress with other
     * plugins. More info [here](https://github.com/allure-framework/allure-js/blob/main/packages/allure-cypress/README.md#setupnodeevents-limitations).
     * @param spec The first argument of the `after:spec` event.
     * @param results The second argument of the `after:spec` event. It's `undefined` in interactive mode.
     * @example
     * ```javascript
     * import { defineConfig } from "cypress";
     * import { allureCypress } from "allure-cypress/reporter";
     *
     * export default defineConfig({
     *   setupNodeEvents: (on, config) => {
     *     const allureReporter = allureCypress(on, config);
     *     on("after:spec", (spec, results) => {
     *       allureReporter.onAfterSpec(spec, results);
     *     });
     *     return config;
     *   }
     *   // ...
     * });
     * ```
     */
    _defineProperty(this, "onAfterSpec", (spec, results) => {
      var _results$video;
      this.endSpec(spec.absolute, (_results$video = results === null || results === void 0 ? void 0 : results.video) !== null && _results$video !== void 0 ? _results$video : undefined);
    });
    /**
     * Forward the `after:run` event into Allure Cypress using this function if
     * you need to define your own handler or combine Allure Cypress with other
     * plugins. More info [here](https://github.com/allure-framework/allure-js/blob/main/packages/allure-cypress/README.md#setupnodeevents-limitations).
     * @param results The argument of the `after:run` event. It's `undefined` in interactive mode.
     * @example
     * ```javascript
     * import { defineConfig } from "cypress";
     * import { allureCypress } from "allure-cypress/reporter";
     *
     * export default defineConfig({
     *   setupNodeEvents: (on, config) => {
     *     const allureReporter = allureCypress(on, config);
     *     on("after:run", (results) => {
     *       allureReporter.onAfterRun(results);
     *     });
     *     return config;
     *   }
     *   // ...
     * });
     * ```
     */
    _defineProperty(this, "onAfterRun", results => {
      this.endRun();
    });
    _defineProperty(this, "endRun", () => {
      _classPrivateFieldGet(_endAllSpecs, this).call(this);
      this.allureRuntime.writeEnvironmentInfo();
      this.allureRuntime.writeCategoriesDefinitions();
    });
    _defineProperty(this, "endSpec", (specAbsolutePath, cypressVideoPath) => {
      var specContext = this.specContextByAbsolutePath.get(specAbsolutePath);
      if (specContext) {
        _classPrivateFieldGet(_attachSpecVideo, this).call(this, specContext, cypressVideoPath);
        _classPrivateFieldGet(_emitRemainingScopes, this).call(this, specContext);
        this.specContextByAbsolutePath.delete(specAbsolutePath);
      }
    });
    _classPrivateFieldInitSpec(this, _endAllSpecs, () => {
      for (var specAbsolutePath of this.specContextByAbsolutePath.keys()) {
        this.endSpec(specAbsolutePath);
      }
    });
    _classPrivateFieldInitSpec(this, _applyAllureCypressMessages, _ref => {
      var {
        messages,
        absolutePath
      } = _ref;
      messages.forEach(message => {
        if (message.type === "cypress_run_start") {
          _classPrivateFieldGet(_startRun, this).call(this, absolutePath);
          return;
        }
        var context = this.specContextByAbsolutePath.get(absolutePath);
        if (!context) {
          return;
        }
        switch (message.type) {
          case "cypress_suite_start":
            _classPrivateFieldGet(_startSuite, this).call(this, context, message);
            break;
          case "cypress_suite_end":
            _classPrivateFieldGet(_stopSuite, this).call(this, context, message);
            break;
          case "cypress_hook_start":
            _classPrivateFieldGet(_startHook, this).call(this, context, message);
            break;
          case "cypress_hook_end":
            _classPrivateFieldGet(_stopHook, this).call(this, context, message);
            break;
          case "cypress_test_start":
            _classPrivateFieldGet(_startTest, this).call(this, context, message);
            break;
          case "cypress_test_pass":
            _classPrivateFieldGet(_passTest, this).call(this, context);
            break;
          case "cypress_fail":
            _classPrivateFieldGet(_failHookAndTest, this).call(this, context, message);
            break;
          case "cypress_test_skip":
            _classPrivateFieldGet(_skipTest, this).call(this, context, message);
            break;
          case "cypress_skipped_test":
            _classPrivateFieldGet(_addSkippedTest, this).call(this, context, message);
            break;
          case "cypress_test_end":
            _classPrivateFieldGet(_stopTest, this).call(this, context, message);
            break;
          case "cypress_step_start":
            _classPrivateFieldGet(_startStep, this).call(this, context, message.data);
            break;
          case "cypress_step_stop":
            _classPrivateFieldGet(_stopStep, this).call(this, context, message.data);
            break;
          case "cypress_step_finalize":
            _classPrivateFieldGet(_finalizeStep, this).call(this, context, message.data);
            break;
          default:
            _classPrivateFieldGet(_applyRuntimeApiMessages, this).call(this, context, message);
            break;
        }
      });
    });
    _classPrivateFieldInitSpec(this, _startRun, absolutePath => {
      // This function is executed once on `cypress run`, but it can be executed
      // multiple times during an interactive session (`cypress open`). Ideally,
      // in that case, we should remove previous result objects that haven't been
      // written yet, but it would've required support in ReporterRuntime.
      // Currently, we're discarding the entire spec context.
      _classPrivateFieldGet(_initializeSpecContext, this).call(this, absolutePath);
    });
    _classPrivateFieldInitSpec(this, _startSuite, (context, _ref2) => {
      var {
        data: {
          id,
          name,
          root
        }
      } = _ref2;
      _classPrivateFieldGet(_pushNewSuiteScope, this).call(this, context, id);
      if (!root) {
        _classPrivateFieldGet(_emitPreviousTestScope, this).call(this, context);
        context.suiteNames.push(name);
      }
    });
    _classPrivateFieldInitSpec(this, _pushNewSuiteScope, (context, suiteId) => {
      var scope = this.allureRuntime.startScope();
      context.suiteScopes.push(scope);
      context.suiteIdToScope.set(suiteId, scope);
      context.suiteScopeToId.set(scope, suiteId);
      return scope;
    });
    _classPrivateFieldInitSpec(this, _stopSuite, (context, _ref3) => {
      var {
        data: {
          root
        }
      } = _ref3;
      _classPrivateFieldGet(_emitPreviousTestScope, this).call(this, context);
      if (!root) {
        context.suiteNames.pop();
      }
      _classPrivateFieldGet(_writeLastSuiteScope, this).call(this, context);
    });
    _classPrivateFieldInitSpec(this, _writeLastSuiteScope, context => {
      var scope = context.suiteScopes.pop();
      if (scope) {
        var suiteId = context.suiteScopeToId.get(scope);
        if (suiteId) {
          context.suiteScopeToId.delete(scope);
          context.suiteIdToScope.delete(suiteId);
        }
        this.allureRuntime.writeScope(scope);
      }
    });
    _classPrivateFieldInitSpec(this, _startHook, (context, _ref4) => {
      var {
        data: {
          name,
          scopeType,
          position,
          start
        }
      } = _ref4;
      var isEach = scopeType === "each";
      var isAfterEach = position === "after" && isEach;
      if (!isAfterEach) {
        _classPrivateFieldGet(_emitPreviousTestScope, this).call(this, context);
      }
      var scope = isEach ? context.testScope : last(context.suiteScopes);
      if (scope) {
        context.fixture = this.allureRuntime.startFixture(scope, position, {
          name,
          start,
          status: undefined
        });
      }
    });
    _classPrivateFieldInitSpec(this, _stopHook, (context, _ref5) => {
      var {
        data: {
          duration
        }
      } = _ref5;
      var fixtureUuid = context.fixture;
      if (fixtureUuid) {
        this.allureRuntime.updateFixture(fixtureUuid, fixture => {
          var _fixture$status;
          (_fixture$status = fixture.status) !== null && _fixture$status !== void 0 ? _fixture$status : fixture.status = Status.PASSED;
        });
        this.allureRuntime.stopFixture(fixtureUuid, {
          duration
        });
        _classPrivateFieldGet(_fixFixtureStepStops, this).call(this, fixtureUuid);
        context.fixture = undefined;
      }
    });
    _classPrivateFieldInitSpec(this, _startTest, (context, _ref6) => {
      var {
          data: {
            fullNameSuffix
          }
        } = _ref6,
        testResultData = _objectWithoutProperties(_ref6.data, _excluded);
      _classPrivateFieldGet(_emitPreviousTestScope, this).call(this, context);
      var testScope = this.allureRuntime.startScope();
      context.testScope = testScope;
      context.test = _classPrivateFieldGet(_addNewTestResult, this).call(this, context, fullNameSuffix, testResultData, [context.videoScope, ...context.suiteScopes, testScope]);
    });
    _classPrivateFieldInitSpec(this, _addNewTestResult, (context, fullNameSuffix, _ref7, scopes) => {
      var {
          labels: metadataLabels = []
        } = _ref7,
        otherTestData = _objectWithoutProperties(_ref7, _excluded2);
      return this.allureRuntime.startTest(_objectSpread({
        stage: Stage.RUNNING,
        labels: [getLanguageLabel(), getFrameworkLabel("cypress"), ...getSuiteLabels(context.suiteNames), ...metadataLabels, ...getEnvironmentLabels(), getHostLabel(), getThreadLabel(), getPackageLabel(context.specPath)],
        fullName: "".concat(getPosixPath(context.specPath), "#").concat(fullNameSuffix)
      }, otherTestData), scopes);
    });
    _classPrivateFieldInitSpec(this, _failHookAndTest, (context, _ref8) => {
      var {
        data: {
          status,
          statusDetails
        }
      } = _ref8;
      var setError = result => Object.assign(result, {
        status,
        statusDetails
      });
      var fixtureUuid = context.fixture;
      if (fixtureUuid) {
        this.allureRuntime.updateFixture(fixtureUuid, setError);
      }
      var testUuid = context.test;
      if (testUuid) {
        this.allureRuntime.updateTest(testUuid, setError);
      }
      context.failed = true;
    });
    _classPrivateFieldInitSpec(this, _passTest, context => {
      var testUuid = context.test;
      if (testUuid) {
        this.allureRuntime.updateTest(testUuid, testResult => {
          testResult.status = Status.PASSED;
        });
      }
    });
    _classPrivateFieldInitSpec(this, _skipTest, (context, _ref9) => {
      var {
        data: {
          statusDetails
        }
      } = _ref9;
      var testUuid = context.test;
      if (testUuid) {
        this.allureRuntime.updateTest(testUuid, testResult => {
          testResult.status = Status.SKIPPED;
          if (statusDetails) {
            testResult.statusDetails = statusDetails;
          }
        });
      }
    });
    _classPrivateFieldInitSpec(this, _addSkippedTest, (context, _ref10) => {
      var {
          data: {
            fullNameSuffix,
            suites,
            duration,
            retries
          }
        } = _ref10,
        testResultData = _objectWithoutProperties(_ref10.data, _excluded3);
      // Tests skipped because of a hook error may share all suites of the current context
      // or just a part thereof (if it's from a sibling suite).
      var scopes = suites.map(s => context.suiteIdToScope.get(s)).filter(s => Boolean(s));
      var testUuid = _classPrivateFieldGet(_addNewTestResult, this).call(this, context, fullNameSuffix, testResultData, [context.videoScope, ...scopes]);
      _classPrivateFieldGet(_stopExistingTestResult, this).call(this, testUuid, {
        duration,
        retries
      });
      this.allureRuntime.writeTest(testUuid);
    });
    _classPrivateFieldInitSpec(this, _stopTest, (context, _ref11) => {
      var {
        data
      } = _ref11;
      var testUuid = context.test;
      if (testUuid) {
        _classPrivateFieldGet(_stopExistingTestResult, this).call(this, testUuid, data);
        this.allureRuntime.writeTest(testUuid);
        context.test = undefined;
      }
    });
    _classPrivateFieldInitSpec(this, _stopExistingTestResult, (testUuid, _ref12) => {
      var {
        retries,
        duration
      } = _ref12;
      this.allureRuntime.updateTest(testUuid, testResult => {
        if (retries > 0) {
          testResult.parameters.push({
            name: "Retry",
            value: retries.toString(),
            excluded: true
          });
        }
        testResult.stage = Stage.FINISHED;
      });
      this.allureRuntime.stopTest(testUuid, {
        duration
      });
      _classPrivateFieldGet(_fixTestStepStops, this).call(this, testUuid);
    });
    _classPrivateFieldInitSpec(this, _fixTestStepStops, testUuid => {
      this.allureRuntime.updateTest(testUuid, _classPrivateFieldGet(_fixStepStops, this));
    });
    _classPrivateFieldInitSpec(this, _fixFixtureStepStops, fixtureUuid => {
      this.allureRuntime.updateFixture(fixtureUuid, _classPrivateFieldGet(_fixStepStops, this));
    });
    _classPrivateFieldInitSpec(this, _fixStepStops, _ref13 => {
      var {
        stop,
        steps = []
      } = _ref13;
      if (stop) {
        // In some circumstances, steps becomes dangling and are stopped at the test end/hook end events, which happen
        // chronologically after the test or fixture ends. This leads to the steps' stop time being greater than the one
        // of the test/fixture.
        // The only steps that may be affected are the rightmost descendants of the test/fixture.
        for (var step = steps.at(-1); step; step = step.steps.at(-1)) {
          if (step.stop && step.stop > stop) {
            step.stop = stop;
          } else {
            // Steps are always stopped child-to-parent. If a step's stop time is OK, its substeps are also correct.
            return;
          }
        }
      }
    });
    _classPrivateFieldInitSpec(this, _startStep, (context, _ref14) => {
      var {
          id
        } = _ref14,
        properties = _objectWithoutProperties(_ref14, _excluded4);
      var rootUuid = _classPrivateFieldGet(_resolveRootUuid, this).call(this, context);
      if (rootUuid) {
        var stepUuid = this.allureRuntime.startStep(rootUuid, undefined, properties);
        if (stepUuid) {
          context.stepsByFrontEndId.set(id, stepUuid);
        }
      }
    });
    _classPrivateFieldInitSpec(this, _stopStep, (context, _ref15) => {
      var {
          id,
          stop
        } = _ref15,
        properties = _objectWithoutProperties(_ref15, _excluded5);
      var stepUuid = context.stepsByFrontEndId.get(id);
      if (stepUuid) {
        this.allureRuntime.updateStep(stepUuid, r => {
          Object.assign(r, properties);
        });
        this.allureRuntime.stopStep(stepUuid, {
          stop
        });
      }
    });
    _classPrivateFieldInitSpec(this, _finalizeStep, (context, _ref16) => {
      var {
          id
        } = _ref16,
        properties = _objectWithoutProperties(_ref16, _excluded6);
      var stepUuid = context.stepsByFrontEndId.get(id);
      if (stepUuid) {
        this.allureRuntime.updateStep(stepUuid, r => {
          Object.assign(r, properties);
        });
        context.stepsByFrontEndId.delete(id);
      }
    });
    _classPrivateFieldInitSpec(this, _applyRuntimeApiMessages, (context, message) => {
      var rootUuid = _classPrivateFieldGet(_resolveRootUuid, this).call(this, context);
      if (rootUuid) {
        this.allureRuntime.applyRuntimeMessages(rootUuid, [message]);
      }
    });
    /**
     * We must defer emitting a test's scope until we receive all the test's `afterEach` hooks.
     * At the same time, we should report it as early as we can. That means we should call this
     * method in the following cases:
     * - when an `after` hook of the test starts (`after` hooks are called later than `afterEach`)
     * - when a `before` or `beforeEach` hook of the next test starts (in case the next test has `before`/`beforeEach` hooks)
     * - when the next test starts (in case the next test doesn't have `before`/`beforeEach` hooks)
     * - when the test's suite ends (in case the test is the last one in its suite, including the root suite of the spec)
     * - when a nested suite starts
     * - when the spec ends
     */
    _classPrivateFieldInitSpec(this, _emitPreviousTestScope, context => {
      var testScope = context.testScope;

      // Checking the test allows us to tell `beforeEach` and `afterEach` apart.
      // Here we're interested in `afterEach` only.
      if (!context.test && testScope) {
        this.allureRuntime.writeScope(testScope);
        context.testScope = undefined;
      }
    });
    _classPrivateFieldInitSpec(this, _resolveRootUuid, context => {
      var _context$fixture;
      return (_context$fixture = context.fixture) !== null && _context$fixture !== void 0 ? _context$fixture : context.test;
    });
    _classPrivateFieldInitSpec(this, _attachSpecVideo, (context, cypressVideoPath) => {
      var shouldVideoBeAttached = (!this.videoOnFailOnly || context.failed) && cypressVideoPath;
      if (shouldVideoBeAttached) {
        var fixtureUuid = this.allureRuntime.startFixture(context.videoScope, "after", {
          name: "Cypress video",
          status: Status.PASSED,
          stage: Stage.FINISHED
        });
        this.allureRuntime.writeAttachment(fixtureUuid, undefined, "Cypress video", cypressVideoPath, {
          contentType: ContentType.MP4
        });
        this.allureRuntime.stopFixture(fixtureUuid);
        this.allureRuntime.writeScope(context.videoScope);
      }
    });
    _classPrivateFieldInitSpec(this, _emitRemainingScopes, context => {
      _classPrivateFieldGet(_emitPreviousTestScope, this).call(this, context);
      context.suiteScopes.forEach(scope => {
        this.allureRuntime.writeScope(scope);
      });
    });
    _classPrivateFieldInitSpec(this, _initializeSpecContext, absolutePath => {
      var specPath = getRelativePath(absolutePath);
      var context = {
        specPath,
        test: undefined,
        fixture: undefined,
        stepsByFrontEndId: new Map(),
        videoScope: this.allureRuntime.startScope(),
        suiteIdToScope: new Map(),
        suiteScopeToId: new Map(),
        suiteScopes: [],
        testScope: undefined,
        suiteNames: [],
        failed: false
      };
      this.specContextByAbsolutePath.set(absolutePath, context);
    });
    var {
        resultsDir,
        videoOnFailOnly = false
      } = config,
      rest = _objectWithoutProperties(config, _excluded7);
    this.videoOnFailOnly = videoOnFailOnly;
    this.allureRuntime = new ReporterRuntime(_objectSpread({
      writer: createDefaultWriter({
        resultsDir
      })
    }, rest));
  }
}
var createRuntimeState = allureConfig => ({
  config: getRuntimeConfigDefaults(allureConfig),
  initialized: false,
  messages: [],
  testPlan: parseTestPlan(),
  projectDir: getProjectRoot(),
  stepStack: [],
  stepsToFinalize: [],
  nextApiStepId: 0
});
var getRuntimeConfigDefaults = function getRuntimeConfigDefaults() {
  var {
    stepsFromCommands: {
      maxArgumentLength = DEFAULT_RUNTIME_CONFIG.stepsFromCommands.maxArgumentLength,
      maxArgumentDepth = DEFAULT_RUNTIME_CONFIG.stepsFromCommands.maxArgumentDepth
    } = DEFAULT_RUNTIME_CONFIG.stepsFromCommands
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_RUNTIME_CONFIG;
  return {
    stepsFromCommands: {
      maxArgumentDepth,
      maxArgumentLength
    }
  };
};
var initializeRuntimeState = (cypressConfig, allureConfig) => {
  cypressConfig.env.allure = createRuntimeState(allureConfig);
  return cypressConfig;
};

/**
 * Sets up Allure Cypress.
 * @param on The function used to subscribe to Cypress Node events (it's the first argument of `setupNodeEvents`).
 * @param cypressConfig The Cypress configuration (the second argument of `setupNodeEvents`). If provided, the selective run feature will be enabled.
 * @param allureConfig An Allure configuration object (optional).
 * @example
 * ```javascript
 * import { defineConfig } from "cypress";
 * import { allureCypress } from "allure-cypress/reporter";
 *
 * export default defineConfig({
 *   e2e: {
 *     setupNodeEvents: (on, config) => {
 *       allureCypress(on, config, { videoOnFailOnly: true });
 *       return config;
 *     },
 *     // ...
 *   }
 * });
 * ```
 */
export var allureCypress = (on, cypressConfig, allureConfig) => {
  // Backward compatibility; mainly for JS users who have no type hints
  if (!allureConfig && cypressConfig && !("env" in cypressConfig)) {
    allureConfig = cypressConfig;
  }
  var hasCypressConfig = cypressConfig && "env" in cypressConfig;
  var allureCypressReporter = new AllureCypress(allureConfig);
  allureCypressReporter.attachToCypress(on);
  if (hasCypressConfig) {
    initializeRuntimeState(cypressConfig, allureConfig);
  }
  return allureCypressReporter;
};
//# sourceMappingURL=reporter.js.map