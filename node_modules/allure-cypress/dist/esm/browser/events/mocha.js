import { completeHookErrorReporting, completeSpecIfNoAfterHookLeft, flushRuntimeMessages, reportTestPass as onPass, reportTestSkip as onPending, reportSuiteEnd as onSuiteEnd, reportTestEnd as onTestEnd, reportHookEnd, reportHookStart, reportRunStart, reportSuiteStart, reportTestOrHookFail, reportTestStart } from "../lifecycle.js";
import { initTestRuntime } from "../runtime.js";
import { applyTestPlan } from "../testplan.js";
import { isAllureHook, isRootAfterAllHook, isTestReported } from "../utils.js";
export var ALLURE_REPORT_SYSTEM_HOOK = "__allure_report_system_hook__";
export var registerMochaEventListeners = () => {
  Cypress.mocha.getRunner().on("start", onStart).on("suite", onSuite).on("suite end", onSuiteEnd).on("hook", onHook).on("hook end", onHookEnd).on("test", onTest).on("pass", onPass).on("fail", onFail).on("pending", onPending).on("test end", onTestEnd);
};
export var injectFlushMessageHooks = () => {
  afterEach(ALLURE_REPORT_SYSTEM_HOOK, flushRuntimeMessages);
  after(ALLURE_REPORT_SYSTEM_HOOK, onAfterAll);
};
var onStart = () => {
  initTestRuntime();
  reportRunStart();
};
var onSuite = suite => {
  if (suite.root) {
    applyTestPlan(Cypress.spec, suite);
  }
  reportSuiteStart(suite);
};
var onHook = hook => {
  if (isAllureHook(hook)) {
    return;
  }
  reportHookStart(hook);
};
var onHookEnd = hook => {
  if (isAllureHook(hook)) {
    return;
  }
  reportHookEnd(hook);
};
var onTest = test => {
  // Cypress emits an extra EVENT_TEST_BEGIN if the test is skipped.
  // reportTestSkip does that already, so we need to filter the extra event out.
  if (!isTestReported(test)) {
    reportTestStart(test);
  }
};
var onFail = (testOrHook, err) => {
  var isHook = ("hookName" in testOrHook);
  if (isHook && isRootAfterAllHook(testOrHook)) {
    // Errors in spec-level 'after all' hooks are handled by Allure wrappers.
    return;
  }
  var isAllureHookFailure = isHook && isAllureHook(testOrHook);
  if (isAllureHookFailure) {
    var _testOrHook$duration;
    // Normally, Allure hooks are skipped from the report.
    // In case of errors, it will be helpful to see them.
    reportHookStart(testOrHook, Date.now() - ((_testOrHook$duration = testOrHook.duration) !== null && _testOrHook$duration !== void 0 ? _testOrHook$duration : 0));
  }

  // This will mark the fixture and the test (if any) as failed/broken.
  reportTestOrHookFail(err);
  if (isHook) {
    // This will end the fixture and test (if any) and will report the remaining
    // tests in the hook's suite (the ones that will be skipped by Cypress/Mocha).
    completeHookErrorReporting(testOrHook, err);
  }
};
var onAfterAll = function onAfterAll() {
  flushRuntimeMessages();
  completeSpecIfNoAfterHookLeft(this);
};
//# sourceMappingURL=mocha.js.map