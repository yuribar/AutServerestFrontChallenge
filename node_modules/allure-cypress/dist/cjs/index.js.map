{
  "version": 3,
  "sources": ["../../src/index.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/model.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/utils.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/runtime/NoopTestRuntime.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/sdk/runtime/runtime.ts", "../../../../.yarn/__virtual__/allure-js-commons-virtual-2327c51af9/1/packages/allure-js-commons/src/facade.ts", "../../src/utils.ts", "../../src/browser/state.ts", "../../src/browser/testplan.ts", "../../src/browser/events/mocha.ts", "../../src/browser/utils.ts", "../../src/browser/steps.ts", "../../src/browser/runtime.ts", "../../src/browser/lifecycle.ts", "../../src/browser/patching.ts", "../../src/browser/serialize.ts", "../../src/browser/commandLog.ts", "../../src/browser/events/cypress.ts", "../../src/browser/events/index.ts", "../../src/browser/index.ts"],
  "sourcesContent": ["import { initializeAllure } from \"./browser/index.js\";\n\ninitializeAllure();\n\nexport * from \"allure-js-commons\";\n", "export interface Attachment {\n  name: string;\n  type?: string;\n  source: string;\n}\n\nexport interface AttachmentOptions {\n  contentType: ContentType | string;\n  encoding?: BufferEncoding;\n  fileExtension?: string;\n}\n\nexport interface Label {\n  name: LabelName | string;\n  value: string;\n}\n\nexport interface Link {\n  name?: string;\n  url: string;\n  type?: LinkType | string;\n}\n\nexport type ParameterMode = \"hidden\" | \"masked\" | \"default\";\n\nexport interface Parameter {\n  name: string;\n  value: string;\n  excluded?: boolean;\n  mode?: ParameterMode;\n}\n\nexport type ParameterOptions = Pick<Parameter, \"mode\" | \"excluded\">;\n\nexport interface StatusDetails {\n  message?: string;\n  trace?: string;\n  actual?: string;\n  expected?: string;\n}\n\n// don't use the interface as is, use Results types instead\ninterface Executable {\n  name?: string;\n  status?: Status;\n  statusDetails: StatusDetails;\n  stage: Stage;\n  description?: string;\n  descriptionHtml?: string;\n  steps: StepResult[];\n  attachments: Attachment[];\n  parameters: Parameter[];\n  start?: number;\n  stop?: number;\n}\n\nexport interface FixtureResult extends Executable {}\n\nexport interface StepResult extends Executable {}\n\nexport interface TestResult extends Executable {\n  uuid: string;\n  historyId?: string;\n  fullName?: string;\n  testCaseId?: string;\n  labels: Label[];\n  links: Link[];\n}\n\nexport interface TestResultContainer {\n  uuid: string;\n  name?: string;\n  children: string[];\n  befores: FixtureResult[];\n  afters: FixtureResult[];\n}\n\nexport type TestOrStepResult = StepResult | TestResult;\n\n/* eslint-disable no-shadow */\nexport enum Status {\n  FAILED = \"failed\",\n  BROKEN = \"broken\",\n  PASSED = \"passed\",\n  SKIPPED = \"skipped\",\n}\n\nexport const StatusByPriority = [Status.FAILED, Status.BROKEN, Status.PASSED, Status.SKIPPED];\n\n/* eslint-disable no-shadow */\nexport enum Stage {\n  SCHEDULED = \"scheduled\",\n  RUNNING = \"running\",\n  FINISHED = \"finished\",\n  PENDING = \"pending\",\n  INTERRUPTED = \"interrupted\",\n}\n\n/* eslint-disable no-shadow */\nexport enum LabelName {\n  ALLURE_ID = \"ALLURE_ID\",\n  /**\n   * @deprecated please use ALLURE_ID instead\n   */\n  AS_ID = ALLURE_ID,\n  SUITE = \"suite\",\n  PARENT_SUITE = \"parentSuite\",\n  SUB_SUITE = \"subSuite\",\n  EPIC = \"epic\",\n  FEATURE = \"feature\",\n  STORY = \"story\",\n  SEVERITY = \"severity\",\n  TAG = \"tag\",\n  OWNER = \"owner\",\n  LEAD = \"lead\",\n  HOST = \"host\",\n  THREAD = \"thread\",\n  TEST_METHOD = \"testMethod\",\n  TEST_CLASS = \"testClass\",\n  PACKAGE = \"package\",\n  FRAMEWORK = \"framework\",\n  LANGUAGE = \"language\",\n  LAYER = \"layer\",\n}\n\n/* eslint-disable no-shadow */\nexport enum Severity {\n  BLOCKER = \"blocker\",\n  CRITICAL = \"critical\",\n  NORMAL = \"normal\",\n  MINOR = \"minor\",\n  TRIVIAL = \"trivial\",\n}\n\n/* eslint-disable no-shadow */\nexport enum ContentType {\n  TEXT = \"text/plain\",\n  XML = \"application/xml\",\n  HTML = \"text/html\",\n  CSV = \"text/csv\",\n  TSV = \"text/tab-separated-values\",\n  CSS = \"text/css\",\n  URI = \"text/uri-list\",\n  SVG = \"image/svg+xml\",\n  PNG = \"image/png\",\n  JSON = \"application/json\",\n  ZIP = \"application/zip\",\n  WEBM = \"video/webm\",\n  JPEG = \"image/jpeg\",\n  MP4 = \"video/mp4\",\n  IMAGEDIFF = \"application/vnd.allure.image.diff\",\n}\n\n/* eslint-disable no-shadow */\nexport enum LinkType {\n  DEFAULT = \"link\",\n  ISSUE = \"issue\",\n  TMS = \"tms\",\n}\n\nexport interface ImageDiffAttachment {\n  expected: string | undefined; // data:image;base64,\n  actual: string | undefined; // data:image;base64,\n  diff: string | undefined; // data:image;base64,\n  name: string;\n}\n", "import type { FixtureResult, Label, Link, StatusDetails, StepResult, TestResult } from \"../model.js\";\nimport { LabelName, Status } from \"../model.js\";\nimport type { RuntimeMessage, SerializeOptions, SerializerReplacerFunc } from \"./types.js\";\n\nexport const getStatusFromError = (error: Partial<Error>): Status => {\n  switch (true) {\n    /**\n     * Native `node:assert` and `chai` (`vitest` uses it under the hood) throw `AssertionError`\n     * `jest` throws `JestAssertionError` instance\n     * `jasmine` throws `ExpectationFailed` instance\n     * `vitest` throws `Error` for extended assertions, so we look into stack\n     */\n    case /assert/gi.test(error.constructor.name):\n    case /expectation/gi.test(error.constructor.name):\n    case error.name && /assert/gi.test(error.name):\n    case error.message && /assert/gi.test(error.message):\n    case error.stack && /@vitest\\/expect/gi.test(error.stack):\n    case error.stack && /playwright\\/lib\\/matchers\\/expect\\.js/gi.test(error.stack):\n    case \"matcherResult\" in error:\n    case \"inspect\" in error && typeof error.inspect === \"function\":\n      return Status.FAILED;\n    default:\n      return Status.BROKEN;\n  }\n};\n\n/**\n * Source: https://github.com/chalk/ansi-regex\n */\nconst ansiRegex = ({ onlyFirst = false } = {}) => {\n  const pattern = [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\",\n  ].join(\"|\");\n\n  return new RegExp(pattern, onlyFirst ? undefined : \"g\");\n};\n\n/**\n * https://github.com/chalk/strip-ansi\n */\nexport const stripAnsi = (str: string): string => {\n  const regex = ansiRegex();\n  return str.replace(regex, \"\");\n};\n\nconst actualAndExpected = (value: unknown): { actual?: string; expected?: string } => {\n  if (!value || typeof value !== \"object\") {\n    return {};\n  }\n\n  // support for jest asserts\n  if (\"matcherResult\" in value && value.matcherResult !== undefined && typeof value.matcherResult === \"object\") {\n    return {\n      actual: serialize((value.matcherResult as any).actual),\n      expected: serialize((value.matcherResult as any).expected),\n    };\n  }\n\n  const actual = \"actual\" in value && value.actual !== undefined ? { actual: serialize(value.actual) } : {};\n  const expected = \"expected\" in value && value.expected !== undefined ? { expected: serialize(value.expected) } : {};\n  return {\n    ...actual,\n    ...expected,\n  };\n};\n\nexport const getMessageAndTraceFromError = (\n  error:\n    | Error\n    | {\n        message?: string;\n        stack?: string;\n      },\n): StatusDetails => {\n  const { message, stack } = error;\n  return {\n    message: message ? stripAnsi(message) : undefined,\n    trace: stack ? stripAnsi(stack) : undefined,\n    ...actualAndExpected(error),\n  };\n};\n\ntype AllureTitleMetadataMatch = RegExpMatchArray & {\n  groups: {\n    type?: string;\n    v1?: string;\n    v2?: string;\n    v3?: string;\n    v4?: string;\n  };\n};\n\nexport const allureMetadataRegexp = /(?:^|\\s)@?allure\\.(?<type>\\S+)$/;\nexport const allureTitleMetadataRegexp = /(?:^|\\s)@?allure\\.(?<type>[^:=\\s]+)[:=](\"[^\"]+\"|'[^']+'|`[^`]+`|\\S+)/;\nexport const allureTitleMetadataRegexpGlobal = new RegExp(allureTitleMetadataRegexp, \"g\");\nexport const allureIdRegexp = /(?:^|\\s)@?allure\\.id[:=](?<id>\\S+)/;\nexport const allureLabelRegexp = /(?:^|\\s)@?allure\\.label\\.(?<name>[^:=\\s]+)[:=](?<value>[^\\s]+)/;\n\nexport const getTypeFromAllureTitleMetadataMatch = (match: AllureTitleMetadataMatch) => {\n  return match?.[1];\n};\n\nexport const getValueFromAllureTitleMetadataMatch = (match: AllureTitleMetadataMatch) => {\n  const quotesRegexp = /['\"`]/;\n  const quoteOpenRegexp = new RegExp(`^${quotesRegexp.source}`);\n  const quoteCloseRegexp = new RegExp(`${quotesRegexp.source}$`);\n  const matchedValue = match?.[2] ?? \"\";\n\n  if (quoteOpenRegexp.test(matchedValue) && quoteCloseRegexp.test(matchedValue)) {\n    return matchedValue.slice(1, -1);\n  }\n\n  return matchedValue;\n};\n\nexport const isMetadataTag = (tag: string) => {\n  return allureMetadataRegexp.test(tag);\n};\n\nexport const getMetadataLabel = (tag: string, value?: string): Label | undefined => {\n  const match = tag.match(allureMetadataRegexp);\n  const type = match?.groups?.type;\n\n  if (!type) {\n    return undefined;\n  }\n\n  const [subtype, name] = type.split(\".\");\n\n  return {\n    name: subtype === \"id\" ? LabelName.ALLURE_ID : name,\n    value: value ?? \"\",\n  };\n};\n\nexport const extractMetadataFromString = (\n  title: string,\n): {\n  labels: Label[];\n  links: Link[];\n  cleanTitle: string;\n} => {\n  const labels = [] as Label[];\n  const links = [] as Link[];\n  const metadata = title.matchAll(allureTitleMetadataRegexpGlobal);\n  const cleanTitle = title\n    .replaceAll(allureTitleMetadataRegexpGlobal, \"\")\n    .split(\" \")\n    .filter(Boolean)\n    .reduce((acc, word) => {\n      if (/^[\\n\\r]/.test(word)) {\n        return acc + word;\n      }\n\n      return `${acc} ${word}`;\n    }, \"\")\n    .trim();\n\n  for (const m of metadata) {\n    const match = m as AllureTitleMetadataMatch;\n    const type = getTypeFromAllureTitleMetadataMatch(match);\n    const value = getValueFromAllureTitleMetadataMatch(match);\n\n    if (!type || !value) {\n      continue;\n    }\n\n    const [subtype, name] = type.split(\".\");\n\n    switch (subtype) {\n      case \"id\":\n        labels.push({ name: LabelName.ALLURE_ID, value });\n        break;\n      case \"label\":\n        labels.push({ name, value });\n        break;\n      case \"link\":\n        links.push({ type: name, url: value });\n        break;\n    }\n  }\n\n  return {\n    labels,\n    links,\n    cleanTitle,\n  };\n};\n\nexport const isAnyStepFailed = (item: StepResult | TestResult | FixtureResult): boolean => {\n  const isFailed = item.status === Status.FAILED;\n\n  if (isFailed || item.steps.length === 0) {\n    return isFailed;\n  }\n\n  return !!item.steps.find((step) => isAnyStepFailed(step));\n};\n\nexport const isAllStepsEnded = (item: StepResult | TestResult | FixtureResult): boolean => {\n  return item.steps.every((val) => val.stop && isAllStepsEnded(val));\n};\n\nexport const hasLabel = (testResult: TestResult, labelName: LabelName | string): boolean => {\n  return !!testResult.labels.find((l) => l.name === labelName);\n};\n\nexport const hasStepMessage = (messages: RuntimeMessage[]) => {\n  return messages.some((message) => message.type === \"step_start\" || message.type === \"step_stop\");\n};\n\nexport const getStepsMessagesPair = (messages: RuntimeMessage[]) =>\n  messages.reduce((acc, message) => {\n    if (message.type !== \"step_start\" && message.type !== \"step_stop\") {\n      return acc;\n    }\n\n    if (message.type === \"step_start\") {\n      acc.push([message]);\n\n      return acc;\n    }\n\n    const unfinishedStepIdx = acc.findLastIndex((step) => step.length === 1);\n\n    if (unfinishedStepIdx === -1) {\n      return acc;\n    }\n\n    acc[unfinishedStepIdx].push(message);\n\n    return acc;\n  }, [] as RuntimeMessage[][]);\n\nexport const getUnfinishedStepsMessages = (messages: RuntimeMessage[]) => {\n  const grouppedStepsMessage = getStepsMessagesPair(messages);\n\n  return grouppedStepsMessage.filter((step) => step.length === 1);\n};\n\nexport const isPromise = <T = any>(obj: any): obj is PromiseLike<T> =>\n  !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof obj.then === \"function\";\n\nexport const serialize = (value: any, { maxDepth = 0, maxLength = 0, replacer }: SerializeOptions = {}): string =>\n  limitString(\n    typeof value === \"object\" ? JSON.stringify(value, createSerializeReplacer(maxDepth, replacer)) : String(value),\n    maxLength,\n  );\n\nconst createSerializeReplacer = (maxDepth: number, userDefinedReplacer: SerializeOptions[\"replacer\"]) => {\n  const parents: unknown[] = [];\n  const limitingReplacer = function (this: unknown, _: string, value: unknown) {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    while (parents.length > 0 && !Object.is(parents.at(-1), this)) {\n      parents.pop();\n    }\n\n    if ((maxDepth && parents.length >= maxDepth) || parents.includes(value)) {\n      return undefined;\n    }\n\n    parents.push(value);\n\n    return value instanceof Map\n      ? excludeCircularRefsFromMap(parents, value)\n      : value instanceof Set\n        ? excludeCircularRefsFromSet(parents, value)\n        : value;\n  };\n  return userDefinedReplacer ? composeReplacers(userDefinedReplacer, limitingReplacer) : limitingReplacer;\n};\n\nconst composeReplacers = (first: SerializerReplacerFunc, second: SerializerReplacerFunc): SerializerReplacerFunc =>\n  function (k, v) {\n    return second.call(this, k, first.call(this, k, v));\n  };\n\nconst excludeCircularRefsFromMap = (parents: any[], map: Map<any, any>) => {\n  return Array.from(map)\n    .filter(([k]) => !parents.includes(k))\n    .map(([k, v]) => [k, parents.includes(v) ? undefined : v]);\n};\n\nconst excludeCircularRefsFromSet = (parents: any[], set: Set<any>) => {\n  return Array.from(set).map((v) => (parents.includes(v) ? undefined : v));\n};\n\nconst limitString = (value: string, maxLength: number) =>\n  maxLength && value.length > maxLength ? `${value.substring(0, maxLength)}...` : value;\n", "import type { TestRuntime } from \"./types.js\";\n\nexport class NoopTestRuntime implements TestRuntime {\n  async attachment() {\n    await this.warning();\n  }\n\n  async attachmentFromPath() {\n    await this.warning();\n  }\n\n  async description() {\n    await this.warning();\n  }\n\n  async descriptionHtml() {\n    await this.warning();\n  }\n\n  async displayName() {\n    await this.warning();\n  }\n\n  async historyId() {\n    await this.warning();\n  }\n\n  async labels() {\n    await this.warning();\n  }\n\n  async links() {\n    await this.warning();\n  }\n\n  async parameter() {\n    await this.warning();\n  }\n\n  async logStep() {\n    await this.warning();\n  }\n\n  async step<T>(name: string, body: () => T | PromiseLike<T>): Promise<T> {\n    await this.warning();\n    return body();\n  }\n\n  async stepDisplayName() {\n    await this.warning();\n  }\n\n  async stepParameter() {\n    await this.warning();\n  }\n\n  async testCaseId() {\n    await this.warning();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async warning() {\n    // eslint-disable-next-line no-console\n    console.log(\"no test runtime is found. Please check test framework configuration\");\n  }\n}\n\nexport const noopRuntime: TestRuntime = new NoopTestRuntime();\n", "import { noopRuntime } from \"./NoopTestRuntime.js\";\nimport type { TestRuntime } from \"./types.js\";\n\nconst ALLURE_TEST_RUNTIME_KEY = \"allureTestRuntime\";\n\nexport const setGlobalTestRuntime = (runtime: TestRuntime) => {\n  (globalThis as any)[ALLURE_TEST_RUNTIME_KEY] = () => runtime;\n};\n\nconst getGlobalTestRuntimeFunction = () => {\n  return (globalThis as any)?.[ALLURE_TEST_RUNTIME_KEY] as (() => TestRuntime | undefined) | undefined;\n};\n\nexport const getGlobalTestRuntime = (): TestRuntime => {\n  const testRuntime = getGlobalTestRuntimeFunction();\n\n  if (testRuntime) {\n    return testRuntime() ?? noopRuntime;\n  }\n\n  return noopRuntime;\n};\n\nexport const getGlobalTestRuntimeWithAutoconfig = (): TestRuntime | Promise<TestRuntime> => {\n  const testRuntime = getGlobalTestRuntimeFunction();\n\n  if (testRuntime) {\n    return testRuntime() ?? noopRuntime;\n  }\n\n  if (\"_playwrightInstance\" in globalThis) {\n    try {\n      // protection from bundlers tree-shaking visiting (webpack, rollup)\n      // @ts-ignore\n      // eslint-disable-next-line no-eval\n      return (0, eval)(\"(() => import('allure-playwright/autoconfig'))()\").then(() => {\n        return getGlobalTestRuntimeFunction()?.() ?? noopRuntime;\n      });\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.log(\"can't execute allure-playwright/autoconfig\", err);\n      return noopRuntime;\n    }\n  }\n\n  return noopRuntime;\n};\n", "import type { Status } from \"./model.js\";\nimport { type ContentType } from \"./model.js\";\nimport { type AttachmentOptions, type Label, type Link, type ParameterMode, type ParameterOptions } from \"./model.js\";\nimport { LabelName, LinkType } from \"./model.js\";\nimport { getGlobalTestRuntimeWithAutoconfig } from \"./sdk/runtime/runtime.js\";\nimport type { TestRuntime } from \"./sdk/runtime/types.js\";\nimport { isPromise } from \"./sdk/utils.js\";\n\nconst callRuntimeMethod = <\n  T extends keyof TestRuntime,\n  S extends Parameters<TestRuntime[T]>,\n  R extends ReturnType<TestRuntime[T]>,\n>(\n  method: T,\n  ...args: S\n): R => {\n  const runtime = getGlobalTestRuntimeWithAutoconfig();\n\n  if (!isPromise(runtime)) {\n    // @ts-ignore\n    return runtime[method](...args);\n  }\n\n  return runtime.then((testRuntime) => {\n    // @ts-ignore\n    return testRuntime[method](...args);\n  }) as R;\n};\n\nexport const label = (name: LabelName | string, value: string) => {\n  return callRuntimeMethod(\"labels\", { name, value });\n};\n\nexport const labels = (...labelsList: Label[]) => {\n  return callRuntimeMethod(\"labels\", ...labelsList);\n};\n\nexport const link = (url: string, name?: string, type?: LinkType | string) => {\n  return callRuntimeMethod(\"links\", { url, type, name });\n};\n\nexport const links = (...linksList: Link[]) => {\n  return callRuntimeMethod(\"links\", ...linksList);\n};\n\nexport const parameter = (name: string, value: string, options?: ParameterOptions) => {\n  return callRuntimeMethod(\"parameter\", name, value, options);\n};\n\nexport const description = (markdown: string) => {\n  return callRuntimeMethod(\"description\", markdown);\n};\n\nexport const descriptionHtml = (html: string) => {\n  return callRuntimeMethod(\"descriptionHtml\", html);\n};\n\nexport const displayName = (name: string) => {\n  return callRuntimeMethod(\"displayName\", name);\n};\n\nexport const historyId = (value: string) => {\n  return callRuntimeMethod(\"historyId\", value);\n};\n\nexport const testCaseId = (value: string) => {\n  return callRuntimeMethod(\"testCaseId\", value);\n};\n\nexport const attachment = (\n  name: string,\n  content: Buffer | string,\n  options: ContentType | string | AttachmentOptions,\n) => {\n  const opts = typeof options === \"string\" ? { contentType: options } : options;\n  return callRuntimeMethod(\"attachment\", name, content, opts);\n};\n\nexport const attachTrace = (name: string, path: string) => {\n  return callRuntimeMethod(\"attachmentFromPath\", name, path, {\n    contentType: \"application/vnd.allure.playwright-trace\",\n  });\n};\n\nexport const attachmentPath = (\n  name: string,\n  path: string,\n  options: ContentType | string | Omit<AttachmentOptions, \"encoding\">,\n) => {\n  const opts = typeof options === \"string\" ? { contentType: options } : options;\n  return callRuntimeMethod(\"attachmentFromPath\", name, path, opts);\n};\n\nexport type StepContext = {\n  displayName: (name: string) => void | PromiseLike<void>;\n  parameter: (name: string, value: string, mode?: ParameterMode) => void | PromiseLike<void>;\n};\n\nconst stepContext: () => StepContext = () => ({\n  displayName: (name: string) => {\n    return callRuntimeMethod(\"stepDisplayName\", name);\n  },\n  parameter: (name, value, mode?) => {\n    return callRuntimeMethod(\"stepParameter\", name, value, mode);\n  },\n});\n\nexport const logStep = (name: string, status?: Status, error?: Error): PromiseLike<void> => {\n  return callRuntimeMethod(\"logStep\", name, status, error);\n};\n\nexport const step = <T = void>(name: string, body: (context: StepContext) => T | PromiseLike<T>): PromiseLike<T> => {\n  return callRuntimeMethod(\"step\", name, () => body(stepContext()));\n};\n\nexport const issue = (url: string, name?: string) => link(url, name, LinkType.ISSUE);\n\nexport const tms = (url: string, name?: string) => link(url, name, LinkType.TMS);\n\nexport const allureId = (value: string) => label(LabelName.ALLURE_ID, value);\n\nexport const epic = (name: string) => label(LabelName.EPIC, name);\n\nexport const feature = (name: string) => label(LabelName.FEATURE, name);\n\nexport const story = (name: string) => label(LabelName.STORY, name);\n\nexport const suite = (name: string) => label(LabelName.SUITE, name);\n\nexport const parentSuite = (name: string) => label(LabelName.PARENT_SUITE, name);\n\nexport const subSuite = (name: string) => label(LabelName.SUB_SUITE, name);\n\nexport const owner = (name: string) => label(LabelName.OWNER, name);\n\nexport const severity = (name: string) => label(LabelName.SEVERITY, name);\n\nexport const layer = (name: string) => label(LabelName.LAYER, name);\n\nexport const tag = (name: string) => label(LabelName.TAG, name);\n\nexport const tags = (...tagsList: string[]) => {\n  return callRuntimeMethod(\"labels\", ...tagsList.map((value) => ({ name: LabelName.TAG, value })));\n};\n", "export const DEFAULT_RUNTIME_CONFIG = {\n  stepsFromCommands: {\n    maxArgumentLength: 128,\n    maxArgumentDepth: 3,\n  },\n};\n\n/**\n * Pops items from an array into a new one. The item that matches the predicate is the last item to pop.\n * If there is no such item in the array, the array is left unmodified.\n * @param items An array to pop the items from.\n * @param pred A predicate that defines the last item to pop.\n * @returns An array of popped items. The first popped item becomes the first element of this array.\n */\nexport const popUntilFindIncluded = <T>(items: T[], pred: (value: T) => boolean) => {\n  const index = items.findIndex(pred);\n  return index !== -1 ? toReversed(items.splice(index)) : [];\n};\n\nexport const toReversed = <T = unknown>(arr: T[]): T[] => {\n  const len = arr.length;\n  const result: T[] = new Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[len - i - 1] = arr[i];\n  }\n\n  return result;\n};\n\nexport const last = <T = unknown>(arr: T[]): T | undefined => {\n  return arr[arr.length - 1];\n};\n\nexport const isDefined = <T>(value: T | undefined): value is T => typeof value !== \"undefined\";\n", "import type { AllureSpecState, CypressMessage, CypressTest, StepDescriptor, StepFinalizer } from \"../types.js\";\nimport { DEFAULT_RUNTIME_CONFIG, last, toReversed } from \"../utils.js\";\n\nexport const getAllureState = () => {\n  let state = Cypress.env(\"allure\") as AllureSpecState;\n\n  if (!state) {\n    state = {\n      config: DEFAULT_RUNTIME_CONFIG,\n      initialized: false,\n      messages: [],\n      testPlan: undefined,\n      currentTest: undefined,\n      projectDir: undefined,\n      stepStack: [],\n      stepsToFinalize: [],\n      nextApiStepId: 0,\n    };\n\n    Cypress.env(\"allure\", state);\n  }\n\n  return state;\n};\n\nexport const isAllureInitialized = () => getAllureState().initialized;\n\nexport const setAllureInitialized = () => {\n  getAllureState().initialized = true;\n};\n\nexport const getRuntimeMessages = () => getAllureState().messages;\n\nexport const setRuntimeMessages = (value: CypressMessage[]) => {\n  getAllureState().messages = value;\n};\n\nexport const enqueueRuntimeMessage = (message: CypressMessage) => {\n  getRuntimeMessages().push(message);\n};\n\nexport const getAllureTestPlan = () => getAllureState().testPlan;\n\nexport const getProjectDir = () => getAllureState().projectDir;\n\nexport const getCurrentTest = () => getAllureState().currentTest;\n\nexport const setCurrentTest = (test: CypressTest) => {\n  getAllureState().currentTest = test;\n};\n\nexport const dropCurrentTest = () => {\n  getAllureState().currentTest = undefined;\n};\n\nexport const getConfig = () => getAllureState().config;\n\nexport const getStepStack = () => getAllureState().stepStack;\n\nexport const getCurrentStep = () => last(getStepStack());\n\nexport const pushStep = (step: StepDescriptor) => getStepStack().push(step);\n\nexport const popStep = () => getStepStack().pop();\n\nexport const popSteps = (index: number) => toReversed(getStepStack().splice(index));\n\nexport const popAllSteps = () => popSteps(0);\n\nexport const clearStepStack = () => {\n  getAllureState().stepStack = [];\n};\n\nexport const setupStepFinalization = <T extends StepDescriptor>(step: T, finalizer?: StepFinalizer) =>\n  getAllureState().stepsToFinalize.push([step, finalizer]);\n\nexport const getStepsToFinalize = () => getAllureState().stepsToFinalize;\n\nexport const clearStepsToFinalize = () => {\n  const state = getAllureState();\n  state.stepsToFinalize = [];\n};\n", "import { LabelName } from \"allure-js-commons\";\nimport type { TestPlanV1 } from \"allure-js-commons/sdk\";\nimport type { CypressSuite, CypressTest } from \"../types.js\";\nimport { getAllureTestPlan } from \"./state.js\";\nimport { getTestMetadata, resolveSpecRelativePath } from \"./utils.js\";\n\nexport const applyTestPlan = (spec: Cypress.Spec, root: CypressSuite) => {\n  const testPlan = getAllureTestPlan();\n  if (testPlan) {\n    const specPath = resolveSpecRelativePath(spec);\n    for (const suite of iterateSuites(root)) {\n      const indicesToRemove = getIndicesOfDeselectedTests(testPlan, spec, specPath, suite.tests);\n      removeSortedIndices(suite.tests, indicesToRemove);\n    }\n  }\n};\n\nconst iterateSuites = function* (parent: CypressSuite) {\n  const suiteStack: CypressSuite[] = [];\n  for (let s: CypressSuite | undefined = parent; s; s = suiteStack.pop()) {\n    yield s;\n\n    // Pushing in reverse allows us to maintain depth-first pre-order traversal -\n    // the same order as used by Mocha & Cypress.\n    for (let i = s.suites.length - 1; i >= 0; i--) {\n      suiteStack.push(s.suites[i]);\n    }\n  }\n};\n\nconst getIndicesOfDeselectedTests = (\n  testPlan: TestPlanV1,\n  spec: Cypress.Spec,\n  specPath: string,\n  tests: readonly CypressTest[],\n) => {\n  const indicesToRemove: number[] = [];\n  tests.forEach((test, index) => {\n    const { fullNameSuffix, labels } = getTestMetadata(test);\n    const fullName = `${specPath}#${fullNameSuffix}`;\n    const allureId = labels.find(({ name }) => name === LabelName.ALLURE_ID)?.value;\n\n    if (!includedInTestPlan(testPlan, fullName, allureId)) {\n      indicesToRemove.push(index);\n    }\n  });\n  return indicesToRemove;\n};\n\nconst removeSortedIndices = <T>(arr: T[], indices: readonly number[]) => {\n  for (let i = indices.length - 1; i >= 0; i--) {\n    arr.splice(indices[i], 1);\n  }\n};\n\nconst includedInTestPlan = (testPlan: TestPlanV1, fullName: string, allureId: string | undefined): boolean =>\n  testPlan.tests.some((test) => (allureId && test.id?.toString() === allureId) || test.selector === fullName);\n", "import type { CypressHook, CypressSuite, CypressTest } from \"../../types.js\";\nimport {\n  completeHookErrorReporting,\n  completeSpecIfNoAfterHookLeft,\n  flushRuntimeMessages,\n  reportTestPass as onPass,\n  reportTestSkip as onPending,\n  reportSuiteEnd as onSuiteEnd,\n  reportTestEnd as onTestEnd,\n  reportHookEnd,\n  reportHookStart,\n  reportRunStart,\n  reportSuiteStart,\n  reportTestOrHookFail,\n  reportTestStart,\n} from \"../lifecycle.js\";\nimport { initTestRuntime } from \"../runtime.js\";\nimport { applyTestPlan } from \"../testplan.js\";\nimport { isAllureHook, isRootAfterAllHook, isTestReported } from \"../utils.js\";\n\nexport const ALLURE_REPORT_SYSTEM_HOOK = \"__allure_report_system_hook__\";\n\nexport const registerMochaEventListeners = () => {\n  ((Cypress as any).mocha.getRunner() as Mocha.Runner)\n    .on(\"start\", onStart)\n    .on(\"suite\", onSuite)\n    .on(\"suite end\", onSuiteEnd)\n    .on(\"hook\", onHook)\n    .on(\"hook end\", onHookEnd)\n    .on(\"test\", onTest)\n    .on(\"pass\", onPass)\n    .on(\"fail\", onFail)\n    .on(\"pending\", onPending)\n    .on(\"test end\", onTestEnd);\n};\n\nexport const injectFlushMessageHooks = () => {\n  afterEach(ALLURE_REPORT_SYSTEM_HOOK, flushRuntimeMessages);\n  after(ALLURE_REPORT_SYSTEM_HOOK, onAfterAll);\n};\n\nconst onStart = () => {\n  initTestRuntime();\n  reportRunStart();\n};\n\nconst onSuite = (suite: CypressSuite) => {\n  if (suite.root) {\n    applyTestPlan(Cypress.spec, suite);\n  }\n  reportSuiteStart(suite);\n};\n\nconst onHook = (hook: CypressHook) => {\n  if (isAllureHook(hook)) {\n    return;\n  }\n\n  reportHookStart(hook);\n};\n\nconst onHookEnd = (hook: CypressHook) => {\n  if (isAllureHook(hook)) {\n    return;\n  }\n\n  reportHookEnd(hook);\n};\n\nconst onTest = (test: CypressTest) => {\n  // Cypress emits an extra EVENT_TEST_BEGIN if the test is skipped.\n  // reportTestSkip does that already, so we need to filter the extra event out.\n  if (!isTestReported(test)) {\n    reportTestStart(test);\n  }\n};\n\nconst onFail = (testOrHook: CypressTest | CypressHook, err: Error) => {\n  const isHook = \"hookName\" in testOrHook;\n  if (isHook && isRootAfterAllHook(testOrHook)) {\n    // Errors in spec-level 'after all' hooks are handled by Allure wrappers.\n    return;\n  }\n\n  const isAllureHookFailure = isHook && isAllureHook(testOrHook);\n\n  if (isAllureHookFailure) {\n    // Normally, Allure hooks are skipped from the report.\n    // In case of errors, it will be helpful to see them.\n    reportHookStart(testOrHook, Date.now() - (testOrHook.duration ?? 0));\n  }\n\n  // This will mark the fixture and the test (if any) as failed/broken.\n  reportTestOrHookFail(err);\n\n  if (isHook) {\n    // This will end the fixture and test (if any) and will report the remaining\n    // tests in the hook's suite (the ones that will be skipped by Cypress/Mocha).\n    completeHookErrorReporting(testOrHook, err);\n  }\n};\n\nconst onAfterAll = function (this: Mocha.Context) {\n  flushRuntimeMessages();\n  completeSpecIfNoAfterHookLeft(this);\n};\n", "import { Status } from \"allure-js-commons\";\nimport type { StatusDetails } from \"allure-js-commons\";\nimport { extractMetadataFromString, getMessageAndTraceFromError, getStatusFromError } from \"allure-js-commons/sdk\";\nimport type { CypressHook, CypressStepStopMessage, CypressSuite, CypressTest, StepDescriptor } from \"../types.js\";\nimport { ALLURE_REPORT_SYSTEM_HOOK } from \"./events/mocha.js\";\nimport { getAllureState, getProjectDir } from \"./state.js\";\nimport { resolveStepStatus } from \"./steps.js\";\n\nconst IS_WIN = Cypress.platform === \"win32\";\n\nexport const getFileNameFromPath = (path: string) => path.substring(path.lastIndexOf(IS_WIN ? \"\\\\\" : \"/\") + 1);\n\nexport const resolveSpecRelativePath = (spec: Cypress.Spec) => {\n  const projectDir = getProjectDir();\n  const specPath = projectDir ? spec.absolute.substring(projectDir.length + 1) : spec.relative;\n  return IS_WIN ? specPath.replaceAll(\"\\\\\", \"/\") : specPath;\n};\n\nexport const uint8ArrayToBase64 = (data: unknown) => {\n  // @ts-ignore\n  const u8arrayLike = Array.isArray(data) || data.buffer;\n\n  if (!u8arrayLike) {\n    return data as string;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  return btoa(String.fromCharCode.apply(null, data as number[]));\n};\n\nexport const getTestStartData = (test: CypressTest) => ({\n  ...getTestMetadata(test),\n  start:\n    typeof test.wallClockStartedAt === \"string\"\n      ? Date.parse(test.wallClockStartedAt)\n      : test.wallClockStartedAt?.getTime?.() || Date.now(),\n});\n\nexport const getTestStopData = (test: CypressTest) => ({\n  duration: test.duration ?? 0,\n  retries: (test as any)._retries ?? 0,\n});\n\nexport const getTestSkipData = () => ({\n  statusDetails: { message: \"This is a pending test\" },\n});\n\nexport const getStepStopData = (step: StepDescriptor, status?: Status, statusDetails?: StatusDetails) => {\n  const data: CypressStepStopMessage[\"data\"] = {\n    id: step.id,\n    stop: Date.now(),\n    status: status ?? resolveStepStatus(step),\n  };\n  if (statusDetails) {\n    data.statusDetails = statusDetails;\n  }\n  return data;\n};\n\nconst testReportedKey = Symbol(\"The test has been reported to Allure\");\n\nexport const markTestAsReported = (test: CypressTest) => {\n  (test as any)[testReportedKey] = true;\n};\n\nexport const isTestReported = (test: CypressTest) => (test as any)[testReportedKey] === true;\n\nexport const iterateSuites = function* (parent: CypressSuite) {\n  const suiteStack: CypressSuite[] = [];\n  for (let s: CypressSuite | undefined = parent; s; s = suiteStack.pop()) {\n    yield s;\n\n    // Pushing in reverse allows us to maintain depth-first pre-order traversal;\n    // the same order is used by Mocha & Cypress.\n    for (let i = s.suites.length - 1; i >= 0; i--) {\n      suiteStack.push(s.suites[i]);\n    }\n  }\n};\n\nexport const iterateTests = function* (parent: CypressSuite) {\n  for (const suite of iterateSuites(parent)) {\n    yield* suite.tests;\n  }\n};\n\nexport const getSuitePath = (test: CypressTest) => {\n  const suites: CypressSuite[] = [];\n  for (let s: CypressSuite | undefined = test.parent; s; s = s.parent) {\n    suites.push(s);\n  }\n  suites.reverse();\n  return suites;\n};\n\nexport const getSuiteTitlePath = (test: CypressTest): string[] =>\n  getSuitePath(test)\n    .filter((s) => s.title)\n    .map((s) => s.title);\n\nexport const generateApiStepId = () => (getAllureState().nextApiStepId++).toString();\n\nexport const getTestMetadata = (test: CypressTest) => {\n  const rawName = test.title;\n  const { cleanTitle: name, labels, links } = extractMetadataFromString(rawName);\n  const suites = test.titlePath().slice(0, -1);\n  const fullNameSuffix = `${[...suites, name].join(\" \")}`;\n  return { name, labels, links, fullNameSuffix };\n};\n\nexport const isAllureHook = (hook: CypressHook) => hook.title.includes(ALLURE_REPORT_SYSTEM_HOOK);\n\nexport const isRootAfterAllHook = (hook: CypressHook) => hook.parent!.root && hook.hookName === \"after all\";\n\nexport const isLastRootAfterHook = (context: Mocha.Context) => {\n  const currentAfterAll = context.test as CypressHook;\n  const rootSuite = (context.test as CypressHook).parent!;\n  const hooks = (rootSuite as any).hooks as CypressHook[];\n  const lastAfterAll = hooks.findLast((h) => h.hookName === \"after all\");\n  return lastAfterAll?.hookId === currentAfterAll.hookId;\n};\n\nexport const getStatusDataOfTestSkippedByHookError = (\n  hookTitle: string,\n  isEachHook: boolean,\n  err: Error,\n  suite: CypressSuite,\n) => {\n  const status = isEachHook ? Status.SKIPPED : getStatusFromError(err);\n  const { message, trace } = getMessageAndTraceFromError(err);\n  return {\n    status,\n    statusDetails: {\n      message: isEachHook ? getSkipReason(hookTitle, suite) : message,\n      trace,\n    },\n  };\n};\n\nconst getSkipReason = (hookTitle: string, suite: CypressSuite) => {\n  const suiteName = suite.title ? `'${suite.title}'` : \"root\";\n  return `'${hookTitle}' defined in the ${suiteName} suite has failed`;\n};\n", "import type { StatusDetails } from \"allure-js-commons\";\nimport { Status } from \"allure-js-commons\";\nimport { getMessageAndTraceFromError, getStatusFromError } from \"allure-js-commons/sdk\";\nimport type {\n  ApiStepDescriptor,\n  CypressStepFinalizeMessage,\n  LogStepDescriptor,\n  StepDescriptor,\n  StepFinalizer,\n} from \"../types.js\";\nimport { popUntilFindIncluded } from \"../utils.js\";\nimport { reportStepStart, reportStepStop } from \"./lifecycle.js\";\nimport {\n  clearStepsToFinalize,\n  enqueueRuntimeMessage,\n  getStepStack,\n  getStepsToFinalize,\n  popAllSteps,\n  pushStep,\n  setupStepFinalization,\n} from \"./state.js\";\nimport { generateApiStepId } from \"./utils.js\";\n\nexport const ALLURE_STEP_CMD_SUBJECT = {};\n\nexport const isApiStep = (descriptor: StepDescriptor): descriptor is ApiStepDescriptor => {\n  return descriptor.type === \"api\";\n};\n\nexport const isLogStep = (descriptor: StepDescriptor): descriptor is LogStepDescriptor => {\n  return descriptor.type === \"log\";\n};\n\nexport const startAllureApiStep = (name: string) => reportStepStart(pushAllureStep(), name);\n\nexport const pushAllureStep = () => {\n  const id = generateApiStepId();\n  pushStep({ id, type: \"api\" });\n  return id;\n};\n\nexport const reportStepError = (error: Error) => {\n  const status = getStatusFromError(error);\n  const statusDetails = getMessageAndTraceFromError(error);\n\n  // Cypress will abort the test/hook execution soon. No subsequent commands will be run, including the ones that\n  // have been scheduled by `allure.step` to stop the currently running steps.\n  // Additionally, we can't tell in advance if the current command log steps will be stopped normally or not.\n  //\n  // Given that, this function will stop all consecutive Allure API steps at the tip of the step stack.\n  // The command log steps will be given a chance to stop normally to get the most correct timings.\n  //\n  // The command log steps that won't stop normally (and Allure API substeps thereof) will be stopped during the\n  // test/hook finalization phase.\n  stopAllureApiStepStackTip(status, statusDetails);\n\n  // It's not guaranteed for command log steps and intermediate Allure API steps to have access to the error at the\n  // moment they are stopped.\n  // Additionally, Cypress may not update the stack trace of the error at that time. Until that happens, the stack\n  // trace points deep in the bundled code, which is little to no use for the user. Therefore, we need to associate\n  // the remaining steps with the error object to grab the updated stack trace later.\n  associateErrorWithRunningSteps(error);\n};\n\nexport const stopCurrentAllureApiStep = (status?: Status, statusDetails?: StatusDetails) =>\n  findAndStopStepWithSubsteps((stepDescriptor) => isApiStep(stepDescriptor), status, statusDetails);\n\nexport const findAndStopStepWithSubsteps = (\n  pred: (stepEntry: StepDescriptor) => boolean,\n  status?: Status,\n  statusDetails?: StatusDetails,\n) => stopSelectedSteps(popUntilFindIncluded(getStepStack(), pred), status, statusDetails);\n\nexport const stopAllSteps = (status?: Status, statusDetails?: StatusDetails) =>\n  stopSelectedSteps(popAllSteps(), status, statusDetails);\n\nexport const finalizeSteps = () => {\n  // This will stop all dangling steps (like log groups with missing endGroup calls or logs that haven't been\n  // finished by Cypress due to an error).\n  stopAllSteps();\n\n  getStepsToFinalize().forEach(finalizeOneStep);\n  clearStepsToFinalize();\n};\n\nexport const resolveStepStatus = (step: StepDescriptor) =>\n  step.error ? getStatusFromError(step.error) : Status.PASSED;\n\nconst finalizeOneStep = ([step, finalizer]: [StepDescriptor, StepFinalizer | undefined]) => {\n  const { id, error } = step;\n  const data: CypressStepFinalizeMessage[\"data\"] = { id };\n\n  if (error) {\n    // Cypress rewrites the stack trace of an error to point to the location in the test file. Until then, the stack\n    // trace points inside the messy bundle, which is not helpful. There are circumstances when we can't be sure this\n    // has happened when a step is about to stop. That's why we defer setting the status details until we are sure\n    // Cypress does its job.\n    data.statusDetails = getMessageAndTraceFromError(error);\n  }\n\n  finalizer?.(data);\n\n  enqueueRuntimeMessage({\n    type: \"cypress_step_finalize\",\n    data,\n  });\n};\n\nconst stopAllureApiStepStackTip = (status: Status, statusDetails: StatusDetails) => {\n  const stepStack = getStepStack();\n  const firstApiStepAfterLastLogStep = stepStack.at(stepStack.findLastIndex(isLogStep) + 1);\n  if (firstApiStepAfterLastLogStep) {\n    findAndStopStepWithSubsteps(\n      (logEntryOrMessage) => Object.is(logEntryOrMessage, firstApiStepAfterLastLogStep),\n      status,\n      statusDetails,\n    );\n  }\n};\n\nconst propagateErrorToStepDescriptor = (step: StepDescriptor, errorOfSubstep: Error | undefined) => {\n  if (isLogStep(step)) {\n    const error = step.log.attributes.error;\n    if (error) {\n      return (step.error = error);\n    }\n  }\n\n  if (errorOfSubstep) {\n    step.error = errorOfSubstep;\n  }\n\n  return step.error;\n};\n\nconst stopSelectedSteps = (steps: readonly StepDescriptor[], status?: Status, statusDetails?: StatusDetails) => {\n  let error: Error | undefined;\n  for (const stepEntry of steps) {\n    error = propagateErrorToStepDescriptor(stepEntry, error);\n    stopStep(stepEntry, status, statusDetails);\n  }\n\n  if (error) {\n    associateErrorWithRunningSteps(error);\n  }\n};\n\nconst associateErrorWithRunningSteps = (error: Error) => getStepStack().forEach((step) => (step.error = error));\n\nconst stopStep = (step: StepDescriptor, status?: Status, statusDetails?: StatusDetails) => {\n  reportStepStop(step, status, statusDetails);\n\n  if (isApiStep(step) && step.error) {\n    setupStepFinalization(step);\n  }\n};\n", "import { Status } from \"allure-js-commons\";\nimport type { AttachmentOptions, Label, Link, ParameterMode, ParameterOptions } from \"allure-js-commons\";\nimport { getMessageAndTraceFromError } from \"allure-js-commons/sdk\";\nimport { getGlobalTestRuntime, setGlobalTestRuntime } from \"allure-js-commons/sdk/runtime\";\nimport type { TestRuntime } from \"allure-js-commons/sdk/runtime\";\nimport type { AllureCypressTaskArgs, CypressMessage } from \"../types.js\";\nimport { enqueueRuntimeMessage, getRuntimeMessages, setRuntimeMessages } from \"./state.js\";\nimport { ALLURE_STEP_CMD_SUBJECT, startAllureApiStep, stopCurrentAllureApiStep } from \"./steps.js\";\nimport { uint8ArrayToBase64 } from \"./utils.js\";\n\nexport const initTestRuntime = () => setGlobalTestRuntime(new AllureCypressTestRuntime() as TestRuntime);\n\nexport const getTestRuntime = () => getGlobalTestRuntime() as AllureCypressTestRuntime;\n\nclass AllureCypressTestRuntime implements TestRuntime {\n  constructor() {\n    this.#resetMessages();\n  }\n\n  labels(...labels: Label[]) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        labels,\n      },\n    });\n  }\n\n  links(...links: Link[]) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        links,\n      },\n    });\n  }\n\n  parameter(name: string, value: string, options?: ParameterOptions) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        parameters: [\n          {\n            name,\n            value,\n            ...options,\n          },\n        ],\n      },\n    });\n  }\n\n  description(markdown: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        description: markdown,\n      },\n    });\n  }\n\n  descriptionHtml(html: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        descriptionHtml: html,\n      },\n    });\n  }\n\n  displayName(name: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        displayName: name,\n      },\n    });\n  }\n\n  historyId(value: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        historyId: value,\n      },\n    });\n  }\n\n  testCaseId(value: string) {\n    return this.#enqueueMessageAsync({\n      type: \"metadata\",\n      data: {\n        testCaseId: value,\n      },\n    });\n  }\n\n  // @ts-ignore\n  attachment(name: string, content: string, options: AttachmentOptions) {\n    // @ts-ignore\n    const attachmentRawContent: string | Uint8Array = content?.type === \"Buffer\" ? content.data : content;\n    const actualEncoding = typeof attachmentRawContent === \"string\" ? \"utf8\" : \"base64\";\n    const attachmentContent = uint8ArrayToBase64(attachmentRawContent);\n\n    return this.#enqueueMessageAsync({\n      type: \"attachment_content\",\n      data: {\n        name,\n        content: attachmentContent,\n        encoding: actualEncoding,\n        contentType: options.contentType,\n        fileExtension: options.fileExtension,\n      },\n    });\n  }\n\n  attachmentFromPath(name: string, path: string, options: Omit<AttachmentOptions, \"encoding\">) {\n    return this.#enqueueMessageAsync({\n      type: \"attachment_path\",\n      data: {\n        name,\n        path,\n        contentType: options.contentType,\n        fileExtension: options.fileExtension,\n      },\n    });\n  }\n\n  logStep(name: string, status: Status = Status.PASSED, error?: Error) {\n    return cy\n      .wrap(ALLURE_STEP_CMD_SUBJECT, { log: false })\n      .then(() => {\n        startAllureApiStep(name);\n        return Cypress.Promise.resolve();\n      })\n      .then(() => {\n        stopCurrentAllureApiStep(status, error ? getMessageAndTraceFromError(error) : undefined);\n        return Cypress.Promise.resolve();\n      });\n  }\n\n  step<T = void>(name: string, body: () => T | PromiseLike<T>) {\n    return cy\n      .wrap(ALLURE_STEP_CMD_SUBJECT, { log: false })\n      .then(() => {\n        startAllureApiStep(name);\n        return Cypress.Promise.resolve(body());\n      })\n      .then((result) => {\n        stopCurrentAllureApiStep();\n        return result;\n      });\n  }\n\n  stepDisplayName(name: string) {\n    return this.#enqueueMessageAsync({\n      type: \"step_metadata\",\n      data: {\n        name,\n      },\n    });\n  }\n\n  stepParameter(name: string, value: string, mode?: ParameterMode) {\n    return this.#enqueueMessageAsync({\n      type: \"step_metadata\",\n      data: {\n        parameters: [{ name, value, mode }],\n      },\n    });\n  }\n\n  flushAllureMessagesToTask(taskName: string) {\n    const messages = this.#dequeueAllMessages();\n    if (messages.length) {\n      cy.task(taskName, { absolutePath: Cypress.spec.absolute, messages }, { log: false });\n    }\n  }\n\n  flushAllureMessagesToTaskAsync(taskName: string): Cypress.Chainable<unknown> | undefined {\n    const messages = this.#dequeueAllMessages();\n    if (messages.length) {\n      const args: AllureCypressTaskArgs = {\n        absolutePath: Cypress.spec.absolute,\n        messages,\n        isInteractive: Cypress.config(\"isInteractive\"),\n      };\n      return cy.task(taskName, args, { log: false });\n    }\n  }\n\n  #resetMessages() {\n    setRuntimeMessages([]);\n  }\n\n  #enqueueMessageAsync(message: CypressMessage): PromiseLike<void> {\n    enqueueRuntimeMessage(message);\n    return Cypress.Promise.resolve();\n  }\n\n  #dequeueAllMessages() {\n    const messages = getRuntimeMessages();\n    this.#resetMessages();\n    return messages;\n  }\n}\n", "import { ContentType, Status } from \"allure-js-commons\";\nimport type { StatusDetails } from \"allure-js-commons\";\nimport { getMessageAndTraceFromError, getStatusFromError } from \"allure-js-commons/sdk\";\nimport type { CypressFailMessage, CypressHook, CypressSuite, CypressTest, StepDescriptor } from \"../types.js\";\nimport { getTestRuntime } from \"./runtime.js\";\nimport { dropCurrentTest, enqueueRuntimeMessage, getCurrentTest, setCurrentTest } from \"./state.js\";\nimport { finalizeSteps, stopAllSteps } from \"./steps.js\";\nimport {\n  getStatusDataOfTestSkippedByHookError,\n  getStepStopData,\n  getSuitePath,\n  getTestSkipData,\n  getTestStartData,\n  getTestStopData,\n  isAllureHook,\n  isLastRootAfterHook,\n  isTestReported,\n  iterateTests,\n  markTestAsReported,\n} from \"./utils.js\";\n\nexport const reportRunStart = () => {\n  enqueueRuntimeMessage({\n    type: \"cypress_run_start\",\n    data: {},\n  });\n};\n\nexport const reportSuiteStart = (suite: CypressSuite) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_suite_start\",\n    data: {\n      id: suite.id,\n      name: suite.title,\n      root: suite.root,\n      start: Date.now(),\n    },\n  });\n};\n\nexport const reportSuiteEnd = (suite: CypressSuite) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_suite_end\",\n    data: {\n      root: suite.root,\n      stop: Date.now(),\n    },\n  });\n};\n\nexport const reportHookStart = (hook: CypressHook, start?: number) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_hook_start\",\n    data: {\n      name: hook.title,\n      scopeType: hook.hookName.includes(\"each\") ? \"each\" : \"all\",\n      position: hook.hookName.includes(\"before\") ? \"before\" : \"after\",\n      start: start ?? Date.now(),\n    },\n  });\n};\n\nexport const reportHookEnd = (hook: CypressHook) => {\n  finalizeSteps();\n  enqueueRuntimeMessage({\n    type: \"cypress_hook_end\",\n    data: {\n      duration: hook.duration ?? 0,\n    },\n  });\n};\n\nexport const reportTestStart = (test: CypressTest) => {\n  setCurrentTest(test);\n  enqueueRuntimeMessage({\n    type: \"cypress_test_start\",\n    data: getTestStartData(test),\n  });\n  markTestAsReported(test);\n};\n\nexport const reportStepStart = (id: string, name: string) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_step_start\",\n    data: {\n      id,\n      name,\n      start: Date.now(),\n    },\n  });\n};\n\nexport const reportStepStop = (step: StepDescriptor, status?: Status, statusDetails?: StatusDetails) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_step_stop\",\n    data: getStepStopData(step, status, statusDetails),\n  });\n};\n\nexport const reportTestPass = () => {\n  enqueueRuntimeMessage({\n    type: \"cypress_test_pass\",\n    data: {},\n  });\n};\n\nexport const reportTestOrHookFail = (err: Error) => {\n  const status = getStatusFromError(err);\n  const statusDetails = getMessageAndTraceFromError(err);\n\n  stopAllSteps(status, statusDetails);\n\n  enqueueRuntimeMessage({\n    type: \"cypress_fail\",\n    data: {\n      status,\n      statusDetails,\n    },\n  });\n};\n\nexport const completeHookErrorReporting = (hook: CypressHook, err: Error) => {\n  const isEachHook = hook.hookName.includes(\"each\");\n  const suite = hook.parent!;\n  const testFailData = getStatusDataOfTestSkippedByHookError(hook.title, isEachHook, err, suite);\n\n  // Cypress doens't emit 'hook end' if the hook has failed.\n  reportHookEnd(hook);\n\n  // Cypress doens't emit 'test end' if the hook has failed.\n  // We must report the test's end manualy in case of a 'before each' hook.\n  reportCurrentTestIfAny();\n\n  // Cypress skips the remaining tests in the suite of a failed hook.\n  // We should include them to the report manually.\n  reportRemainingTests(suite, testFailData);\n};\n\nexport const reportTestSkip = (test: CypressTest) => {\n  if (isTestReported(test)) {\n    stopAllSteps(Status.SKIPPED, {\n      message: \"The test was skipped before the command was completed\",\n    });\n  } else {\n    reportTestStart(test);\n  }\n\n  enqueueRuntimeMessage({\n    type: \"cypress_test_skip\",\n    data: getTestSkipData(),\n  });\n};\n\nexport const reportTestEnd = (test: CypressTest) => {\n  finalizeSteps();\n  enqueueRuntimeMessage({\n    type: \"cypress_test_end\",\n    data: {\n      duration: test.duration ?? 0,\n      retries: (test as any)._retries ?? 0,\n    },\n  });\n  dropCurrentTest();\n};\n\nexport const reportScreenshot = (path: string, name: string) => {\n  enqueueRuntimeMessage({\n    type: \"attachment_path\",\n    data: { path, name, contentType: ContentType.PNG },\n  });\n};\n\nexport const completeSpecIfNoAfterHookLeft = (context: Mocha.Context) => {\n  if (isLastRootAfterHook(context)) {\n    const hook = context.test as CypressHook;\n    if (!isAllureHook(hook)) {\n      reportHookEnd(hook);\n    }\n    return completeSpecAsync();\n  }\n};\n\nexport const completeSpecOnAfterHookFailure = (\n  context: Mocha.Context,\n  hookError: Error,\n): Cypress.Chainable<unknown> | undefined => {\n  try {\n    reportTestOrHookFail(hookError);\n    completeHookErrorReporting(context.test as CypressHook, hookError);\n\n    // cy.task's then doesn't have onrejected, that's why we don't log async Allure errors here.\n    return completeSpecAsync();\n  } catch (allureError) {\n    logAllureRootAfterError(context, allureError);\n  }\n};\n\nexport const throwAfterSpecCompletion = (context: Mocha.Context, err: any) => {\n  const chain = completeSpecOnAfterHookFailure(context, err as Error)?.then(() => {\n    throw err;\n  });\n  if (!chain) {\n    throw err;\n  }\n};\n\nexport const flushRuntimeMessages = () => getTestRuntime().flushAllureMessagesToTask(\"reportAllureCypressSpecMessages\");\n\nexport const completeSpecAsync = () =>\n  getTestRuntime().flushAllureMessagesToTaskAsync(\"reportFinalAllureCypressSpecMessages\");\n\nconst reportCurrentTestIfAny = () => {\n  const currentTest = getCurrentTest();\n  if (currentTest) {\n    reportTestEnd(currentTest);\n  }\n};\n\nconst reportRemainingTests = (suite: CypressSuite, testFailData: CypressFailMessage[\"data\"]) => {\n  for (const test of iterateTests(suite)) {\n    // Some tests in the suite might've been already reported.\n    if (!isTestReported(test)) {\n      reportTestsSkippedByHookError(\n        test,\n        test.pending ? { ...getTestSkipData(), status: Status.SKIPPED } : testFailData,\n      );\n    }\n  }\n};\n\nconst reportTestsSkippedByHookError = (test: CypressTest, testFailData: CypressFailMessage[\"data\"]) => {\n  enqueueRuntimeMessage({\n    type: \"cypress_skipped_test\",\n    data: {\n      ...getTestStartData(test),\n      ...testFailData,\n      ...getTestStopData(test),\n      suites: getSuitePath(test).map((s) => s.id),\n    },\n  });\n  markTestAsReported(test);\n};\n\nconst logAllureRootAfterError = (context: Mocha.Context, err: unknown) => {\n  // We play safe and swallow errors here to keep the original 'after all' error.\n  try {\n    // eslint-disable-next-line no-console\n    console.error(`Unexpected error when reporting the failure of ${context.test?.title ?? \"'after all'\"}`);\n    // eslint-disable-next-line no-console\n    console.error(err);\n  } catch {}\n};\n", "import { isPromise } from \"allure-js-commons/sdk\";\nimport type { CypressSuiteFunction, DirectHookImplementation, HookImplementation } from \"../types.js\";\nimport {\n  completeSpecIfNoAfterHookLeft,\n  completeSpecOnAfterHookFailure,\n  throwAfterSpecCompletion,\n} from \"./lifecycle.js\";\n\ntype SuiteDepthCounter = {\n  getSuiteDepth: () => number;\n  incrementSuiteDepth: () => void;\n  decrementSuiteDepth: () => void;\n};\n\n/**\n * Patches the `after` function, to inject reporting of spec-level\n * `after` hooks defined by the user.\n */\nexport const enableScopeLevelAfterHookReporting = () => {\n  const suiteDepthCounter = createSuiteDepthCounterState();\n  patchDescribe(suiteDepthCounter);\n  patchAfter(suiteDepthCounter);\n};\n\nconst createSuiteDepthCounterState = (): SuiteDepthCounter => {\n  let suiteDepth = 0;\n  return {\n    getSuiteDepth: () => suiteDepth,\n    incrementSuiteDepth: () => {\n      suiteDepth++;\n    },\n    decrementSuiteDepth: () => {\n      suiteDepth--;\n    },\n  };\n};\n\nconst patchDescribe = ({ incrementSuiteDepth, decrementSuiteDepth }: SuiteDepthCounter) => {\n  const patchDescribeFn =\n    (target: CypressSuiteFunction): CypressSuiteFunction =>\n    (title, configOrFn, fn) => {\n      incrementSuiteDepth();\n      try {\n        return forwardDescribeCall(target, title, configOrFn, fn);\n      } finally {\n        decrementSuiteDepth();\n      }\n    };\n  const originalDescribeFn: Mocha.SuiteFunction = globalThis.describe;\n  const patchedDescribe = patchDescribeFn(originalDescribeFn) as Mocha.SuiteFunction;\n  patchedDescribe.only = patchDescribeFn(\n    originalDescribeFn.only as CypressSuiteFunction,\n  ) as Mocha.ExclusiveSuiteFunction;\n  patchedDescribe.skip = patchDescribeFn(originalDescribeFn.skip as CypressSuiteFunction) as Mocha.PendingSuiteFunction;\n  globalThis.describe = patchedDescribe;\n};\n\nconst patchAfter = ({ getSuiteDepth }: SuiteDepthCounter) => {\n  const originalAfter = globalThis.after;\n  const patchedAfter = (nameOrFn: string | HookImplementation, fn?: HookImplementation): void => {\n    return typeof nameOrFn === \"string\"\n      ? originalAfter(nameOrFn, wrapRootAfterFn(getSuiteDepth, fn))\n      : originalAfter(wrapRootAfterFn(getSuiteDepth, nameOrFn)!);\n  };\n  globalThis.after = patchedAfter;\n};\n\nconst forwardDescribeCall = (target: CypressSuiteFunction, ...args: Parameters<CypressSuiteFunction>) => {\n  const [title, configOrFn, fn] = args;\n  if (typeof fn === \"undefined\" && typeof configOrFn === \"undefined\") {\n    return target(title);\n  } else if (typeof configOrFn === \"function\") {\n    return target(title, configOrFn);\n  } else {\n    return target(title, configOrFn, fn);\n  }\n};\n\nconst wrapRootAfterFn = (getSuiteDepth: () => number, fn?: HookImplementation): HookImplementation | undefined => {\n  if (getSuiteDepth() === 0 && fn) {\n    const wrappedFn = fn.length ? wrapAfterFnWithCallback(fn) : wrapAfterFnWithoutArgs(fn as DirectHookImplementation);\n    Object.defineProperty(wrappedFn, \"name\", { value: fn.name });\n    return wrappedFn;\n  }\n  return fn;\n};\n\nconst wrapAfterFnWithCallback = (fn: Mocha.Func): Mocha.Func => {\n  return function (this: Mocha.Context, done: Mocha.Done) {\n    const wrappedDone = (hookError?: Error) => {\n      if (hookError) {\n        if (!completeSpecOnAfterHookFailure(this, hookError)?.then(() => done(hookError))) {\n          done(hookError);\n        }\n        return;\n      }\n\n      try {\n        if (completeSpecIfNoAfterHookLeft(this)?.then(() => done())) {\n          return;\n        }\n      } catch (allureError) {\n        done(allureError);\n        return;\n      }\n\n      done();\n    };\n    return fn.bind(this)(wrappedDone);\n  };\n};\n\nconst wrapAfterFnWithoutArgs = (fn: DirectHookImplementation) => {\n  return function (this: Mocha.Context) {\n    let result;\n    let syncError: any;\n\n    try {\n      result = fn.bind(this)();\n    } catch (e) {\n      syncError = e;\n    }\n\n    if (syncError) {\n      throwAfterSpecCompletion(this, syncError);\n    } else if (isPromise(result)) {\n      return result.then(\n        () => completeSpecIfNoAfterHookLeft(this),\n        (asyncError) => throwAfterSpecCompletion(this, asyncError),\n      );\n    } else {\n      completeSpecIfNoAfterHookLeft(this);\n      return result;\n    }\n  };\n};\n", "import { serialize } from \"allure-js-commons/sdk\";\nimport { getConfig } from \"./state.js\";\n\nexport default (value: unknown) =>\n  isDomObject(value) ? stringifyAsDom(value) : serialize(value, getSerializeOptions());\n\nconst getSerializeOptions = () => {\n  const {\n    stepsFromCommands: { maxArgumentDepth: maxDepth, maxArgumentLength: maxLength },\n  } = getConfig();\n\n  return { maxDepth, maxLength, nonNullReplacerWithDomSupport };\n};\n\nconst isDomObject = (value: unknown): value is object =>\n  typeof value === \"object\" && value !== null && Cypress.dom.isDom(value);\n\n// @ts-ignore\nconst stringifyAsDom = (value: object) => Cypress.dom.stringify(value, \"long\");\n\nconst nonNullReplacerWithDomSupport = (_: string, value: unknown) => {\n  if (typeof value === \"object\") {\n    // Exclude null properties to make the result more compact.\n    if (value === null) {\n      return undefined;\n    }\n\n    if (Cypress.dom.isDom(value)) {\n      // Window, document, and DOM element properties are serialized with Cypress.dom.stringify.\n      return stringifyAsDom(value);\n    }\n  }\n\n  // Use the implementation from allure-js-commons/sdk in all other cases.\n  return value;\n};\n", "import type { Parameter } from \"allure-js-commons\";\nimport type { CypressLogEntry, LogStepDescriptor } from \"../types.js\";\nimport { isDefined } from \"../utils.js\";\nimport { reportStepStart } from \"./lifecycle.js\";\nimport serializePropValue from \"./serialize.js\";\nimport { getCurrentStep, getStepStack, pushStep, setupStepFinalization } from \"./state.js\";\nimport { ALLURE_STEP_CMD_SUBJECT, findAndStopStepWithSubsteps, isLogStep } from \"./steps.js\";\n\nexport const shouldCreateStepFromCommandLogEntry = (entry: CypressLogEntry) => {\n  const { event, instrument } = entry.attributes;\n  if (instrument !== \"command\") {\n    // We are interested in the \"TEST BODY\" panel only for now.\n    // Other instruments are logged in separate panels.\n    return false;\n  }\n\n  if (event) {\n    // Events are tricky to report as they may span across commands and even leave the test's scope.\n    // We ignore them for now.\n    return false;\n  }\n\n  if (isApiStepErrorLogEntry(entry)) {\n    // Cypress don't create a log message for 'cy.then' except when it throws an error.\n    // This is in particularly happens when the function passed to 'allure.step' throws. In such a case however,\n    // creating an extra step from the log entry is redundant because the error is already included in the report as\n    // a part of the step.\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks if the current step represents a cy.screenshot command log entry. If this is the case, associates the name\n * of the screenshot with the step. Later, that will allow converting the step with the attachment into the attachment\n * step.\n */\nexport const setupScreenshotAttachmentStep = (originalName: string | undefined, name: string) => {\n  const step = getCurrentStep();\n  if (step && isLogStep(step)) {\n    const {\n      name: commandName,\n      props: { name: nameFromProps },\n    } = step.log.attributes.consoleProps();\n    if (commandName === \"screenshot\" && nameFromProps === originalName) {\n      step.attachmentName = name;\n    }\n  }\n};\n\nexport const startCommandLogStep = (entry: CypressLogEntry) => {\n  const currentLogEntry = getCurrentLogEntry();\n\n  if (typeof currentLogEntry !== \"undefined\" && shouldStopCurrentLogStep(currentLogEntry.log, entry)) {\n    stopCommandLogStep(currentLogEntry.log.attributes.id);\n  }\n\n  pushLogEntry(entry);\n  reportStepStart(entry.attributes.id, getCommandLogStepName(entry));\n  scheduleCommandLogStepStop(entry);\n};\n\nexport const stopCommandLogStep = (entryId: string) => findAndStopStepWithSubsteps(({ id }) => id === entryId);\n\nconst pushLogEntry = (entry: CypressLogEntry) => {\n  const id = entry.attributes.id;\n  const stepDescriptor: LogStepDescriptor = { id, type: \"log\", log: entry };\n\n  pushStep(stepDescriptor);\n\n  // Some properties of some Command Log entries are undefined at the time the entry is stopped. An example is the\n  // Yielded property of some queries. We defer converting them to Allure step parameters until the test/hook ends.\n  setupStepFinalization(stepDescriptor, (data) => {\n    data.parameters = getCommandLogStepParameters(entry);\n\n    if (stepDescriptor.attachmentName) {\n      // Rename the step to match the attachment name. Once the names are the same, Allure will render the\n      // attachment in the place of the step.\n      data.name = stepDescriptor.attachmentName;\n    }\n  });\n};\n\nconst scheduleCommandLogStepStop = (entry: CypressLogEntry) => {\n  const { groupStart, end, id } = entry.attributes;\n  if (end) {\n    // Some entries are already completed (this is similar to the idea behind allure.logStep).\n    // Cypress won't call entry.end() in such a case, so we need to stop such a step now.\n    // Example: cy.log\n    stopCommandLogStep(id);\n  } else if (groupStart) {\n    // A logging group must be stopped be the user via the Cypress.Log.endGroup() call.\n    // If the call is missing, the corresponding step will be stopped either at the test's (the hook's) end.\n    const originalEndGroup = entry.endGroup;\n    entry.endGroup = function () {\n      stopCommandLogStep(id);\n      return originalEndGroup.call(this);\n    };\n  } else {\n    // Regular log entries are finalized by Cypress via the Cypress.Log.end() call. We're hooking into this function\n    // to complete the step at the same time.\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const originalEnd = entry.end;\n    entry.end = function () {\n      stopCommandLogStep(id);\n      return originalEnd.call(this);\n    };\n  }\n};\n\nconst isApiStepErrorLogEntry = ({ attributes: { name, consoleProps } }: CypressLogEntry) =>\n  name === \"then\" && Object.is(consoleProps().props[\"Applied To\"], ALLURE_STEP_CMD_SUBJECT);\n\nconst getCommandLogStepName = (entry: CypressLogEntry) => {\n  const { name, message, displayName } = entry.attributes;\n  const resolvedName = (displayName ?? name).trim();\n  const resolvedMessage = (\n    maybeGetAssertionLogMessage(entry) ??\n    maybeGetCucumberLogMessage(entry) ??\n    entry.attributes.renderProps().message ??\n    message\n  ).trim();\n  const stepName = [resolvedName, resolvedMessage].filter(Boolean).join(\" \");\n  return stepName;\n};\n\nconst getCommandLogStepParameters = (entry: CypressLogEntry) =>\n  getLogProps(entry)\n    .map(([k, v]) => ({\n      name: k.toString(),\n      value: serializePropValue(v),\n    }))\n    .filter(getPropValueSetFilter(entry));\n\nconst WELL_KNOWN_CUCUMBER_LOG_NAMES = [\"Given\", \"When\", \"Then\", \"And\"];\n\nconst maybeGetCucumberLogMessage = (entry: CypressLogEntry) => {\n  const {\n    attributes: { name, message },\n  } = entry;\n  if (WELL_KNOWN_CUCUMBER_LOG_NAMES.includes(name.trim()) && message.startsWith(\"**\") && message.endsWith(\"**\")) {\n    return message.substring(2, message.length - 2);\n  }\n};\n\nconst getLogProps = (entry: CypressLogEntry) => {\n  const {\n    attributes: { consoleProps },\n  } = entry;\n  const isAssertionWithMessage = !!maybeGetAssertionLogMessage(entry);\n  const { props, name } = consoleProps();\n\n  // accessing LocalStorage after the page reload can stick the test runner\n  // to avoid the issue, we just need to log the command manually\n  // the problem potentially can happen with other storage related commands, like `clearAllLocalStorage`, `clearAllSessionStorage`, `getAllLocalStorage`, `getAllSessionStorage`, `setLocalStorage`, `setSessionStorage`\n  // but probably, we don't need to silent them all at this moment\n  // the context: https://github.com/allure-framework/allure-js/issues/1222\n  if ([\"clearLocalStorage\"].includes(name)) {\n    return [] as [string, unknown][];\n  }\n\n  // For assertion logs, we interpolate the 'Message' property, which contains unformatted assertion description,\n  // directly into the step's name.\n  // No need to keep the exact same information in the step's parameters.\n  return Object.entries(props).filter(([k, v]) => isDefined(v) && !(isAssertionWithMessage && k === \"Message\"));\n};\n\nconst maybeGetAssertionLogMessage = (entry: CypressLogEntry) => {\n  if (isAssertLog(entry)) {\n    const message = entry.attributes.consoleProps().props.Message;\n\n    if (message && typeof message === \"string\") {\n      return message;\n    }\n  }\n};\n\nconst isAssertLog = ({ attributes: { name } }: CypressLogEntry) => name === \"assert\";\n\nconst getCurrentLogEntry = () => getStepStack().findLast(isLogStep);\n\nconst shouldStopCurrentLogStep = (currentLogEntry: CypressLogEntry, newLogEntry: CypressLogEntry) => {\n  const { groupStart: currentEntryIsGroup, type: currentEntryType } = currentLogEntry.attributes;\n  const { type: newEntryType } = newLogEntry.attributes;\n\n  return !currentEntryIsGroup && (currentEntryType === \"child\" || newEntryType !== \"child\");\n};\n\nconst getPropValueSetFilter = (entry: CypressLogEntry) =>\n  entry.attributes.name === \"wrap\" ? () => true : ({ name, value }: Parameter) => name !== \"Yielded\" || value !== \"{}\";\n", "import type { CypressLogEntry } from \"../../types.js\";\nimport {\n  setupScreenshotAttachmentStep,\n  shouldCreateStepFromCommandLogEntry,\n  startCommandLogStep,\n} from \"../commandLog.js\";\nimport { reportScreenshot } from \"../lifecycle.js\";\nimport { reportStepError } from \"../steps.js\";\nimport { getFileNameFromPath } from \"../utils.js\";\n\nexport const registerCypressEventListeners = () => Cypress.on(\"fail\", onFail).on(\"log:added\", onLogAdded);\n\nexport const enableReportingOfCypressScreenshots = () => Cypress.Screenshot.defaults({ onAfterScreenshot });\n\nconst onAfterScreenshot = (\n  ...[, { name: originalName, path }]: Parameters<Cypress.ScreenshotDefaultsOptions[\"onAfterScreenshot\"]>\n) => {\n  const name = originalName ?? getFileNameFromPath(path);\n\n  reportScreenshot(path, name);\n  setupScreenshotAttachmentStep(originalName, name);\n};\n\nconst onLogAdded = (_: Cypress.ObjectLike, entry: CypressLogEntry) => {\n  if (shouldCreateStepFromCommandLogEntry(entry)) {\n    startCommandLogStep(entry);\n  }\n};\n\nconst onFail = (error: Cypress.CypressError) => {\n  reportStepError(error);\n\n  // If there are more \"fail\" handlers yet to run, it's not our responsibility to throw.\n  // Otherwise, we won't give them any chance to do their job (EventEmitter stops executing handlers as soon\n  // as one of them throws - that is also true for eventemitter2, which is used by the browser-side of Cypress).\n  if (noSubsequentFailListeners()) {\n    throw error;\n  }\n};\n\nconst noSubsequentFailListeners = () => Object.is(Cypress.listeners(\"fail\").at(-1), onFail);\n", "import { enableScopeLevelAfterHookReporting } from \"../patching.js\";\nimport { registerCypressEventListeners } from \"./cypress.js\";\nimport { injectFlushMessageHooks, registerMochaEventListeners } from \"./mocha.js\";\n\nexport const enableAllure = () => {\n  registerMochaEventListeners();\n  registerCypressEventListeners();\n  injectFlushMessageHooks();\n  enableScopeLevelAfterHookReporting();\n};\n\nexport { enableReportingOfCypressScreenshots } from \"./cypress.js\";\n", "import { enableAllure, enableReportingOfCypressScreenshots } from \"./events/index.js\";\nimport { isAllureInitialized, setAllureInitialized } from \"./state.js\";\n\nexport const initializeAllure = () => {\n  if (isAllureInitialized()) {\n    return;\n  }\n\n  setAllureInitialized();\n\n  enableAllure();\n  enableReportingOfCypressScreenshots();\n};\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "ContentType", "LabelName", "LinkType", "Severity", "Stage", "Status", "StatusByPriority", "allureId", "attachTrace", "attachment", "attachmentPath", "description", "descriptionHtml", "displayName", "epic", "feature", "historyId", "issue", "label", "labels", "layer", "link", "links", "logStep", "owner", "parameter", "parentSuite", "severity", "step", "story", "subSuite", "suite", "tag", "tags", "testCaseId", "tms", "__toCommonJS", "Status", "StatusByPriority", "FAILED", "BROKEN", "PASSED", "SKIPPED", "Stage", "LabelName", "Severity", "ContentType", "LinkType", "getStatusFromError", "error", "test", "constructor", "name", "message", "stack", "inspect", "Status", "FAILED", "BROKEN", "ansiRegex", "onlyFirst", "arguments", "length", "undefined", "pattern", "join", "RegExp", "stripAnsi", "str", "regex", "replace", "actualAndExpected", "value", "matcherResult", "actual", "serialize", "expected", "_objectSpread", "getMessageAndTraceFromError", "trace", "allureTitleMetadataRegexp", "_wrapRegExp", "type", "allureTitleMetadataRegexpGlobal", "RegExp", "getTypeFromAllureTitleMetadataMatch", "match", "getValueFromAllureTitleMetadataMatch", "_match$", "quotesRegexp", "quoteOpenRegexp", "RegExp", "concat", "source", "quoteCloseRegexp", "matchedValue", "test", "slice", "extractMetadataFromString", "title", "labels", "links", "metadata", "matchAll", "allureTitleMetadataRegexpGlobal", "cleanTitle", "replaceAll", "split", "filter", "Boolean", "reduce", "acc", "word", "test", "concat", "trim", "m", "match", "type", "getTypeFromAllureTitleMetadataMatch", "value", "getValueFromAllureTitleMetadataMatch", "subtype", "name", "push", "LabelName", "ALLURE_ID", "url", "isPromise", "obj", "then", "serialize", "value", "maxDepth", "maxLength", "replacer", "arguments", "length", "undefined", "limitString", "JSON", "stringify", "createSerializeReplacer", "String", "userDefinedReplacer", "parents", "limitingReplacer", "_", "Object", "is", "at", "pop", "includes", "push", "Map", "excludeCircularRefsFromMap", "Set", "excludeCircularRefsFromSet", "composeReplacers", "first", "second", "k", "v", "call", "map", "Array", "from", "filter", "_ref", "_ref2", "set", "concat", "substring", "NoopTestRuntime", "attachment", "_this", "_asyncToGenerator", "warning", "attachmentFromPath", "_this2", "description", "_this3", "descriptionHtml", "_this4", "displayName", "_this5", "historyId", "_this6", "labels", "_this7", "links", "_this8", "parameter", "_this9", "logStep", "_this10", "step", "name", "body", "_this11", "stepDisplayName", "_this12", "stepParameter", "_this13", "testCaseId", "_this14", "console", "log", "noopRuntime", "ALLURE_TEST_RUNTIME_KEY", "setGlobalTestRuntime", "runtime", "globalThis", "getGlobalTestRuntimeFunction", "getGlobalTestRuntime", "testRuntime", "_testRuntime", "noopRuntime", "getGlobalTestRuntimeWithAutoconfig", "_testRuntime2", "eval", "then", "_getGlobalTestRuntime", "_getGlobalTestRuntime2", "err", "console", "log", "callRuntimeMethod", "method", "_len", "arguments", "length", "args", "Array", "_key", "runtime", "getGlobalTestRuntimeWithAutoconfig", "isPromise", "then", "testRuntime", "label", "name", "value", "labels", "_len2", "labelsList", "_key2", "link", "url", "type", "links", "_len3", "linksList", "_key3", "parameter", "options", "description", "markdown", "descriptionHtml", "html", "displayName", "historyId", "testCaseId", "attachment", "content", "opts", "contentType", "attachTrace", "path", "attachmentPath", "stepContext", "mode", "logStep", "status", "error", "step", "body", "issue", "LinkType", "ISSUE", "tms", "TMS", "allureId", "LabelName", "ALLURE_ID", "epic", "EPIC", "feature", "FEATURE", "story", "STORY", "suite", "SUITE", "parentSuite", "PARENT_SUITE", "subSuite", "SUB_SUITE", "owner", "OWNER", "severity", "SEVERITY", "layer", "LAYER", "tag", "TAG", "tags", "_len4", "tagsList", "_key4", "map", "DEFAULT_RUNTIME_CONFIG", "popUntilFindIncluded", "items", "pred", "index", "toReversed", "arr", "len", "result", "i", "last", "isDefined", "value", "getAllureState", "state", "DEFAULT_RUNTIME_CONFIG", "isAllureInitialized", "setAllureInitialized", "getRuntimeMessages", "setRuntimeMessages", "value", "enqueueRuntimeMessage", "message", "getAllureTestPlan", "getProjectDir", "getCurrentTest", "setCurrentTest", "test", "dropCurrentTest", "getConfig", "getStepStack", "getCurrentStep", "last", "pushStep", "step", "popSteps", "index", "toReversed", "getStepStack", "popAllSteps", "setupStepFinalization", "step", "finalizer", "getAllureState", "getStepsToFinalize", "clearStepsToFinalize", "state", "applyTestPlan", "spec", "root", "testPlan", "getAllureTestPlan", "specPath", "resolveSpecRelativePath", "suite", "iterateSuites", "indicesToRemove", "getIndicesOfDeselectedTests", "removeSortedIndices", "parent", "suiteStack", "s", "i", "tests", "test", "index", "fullNameSuffix", "labels", "getTestMetadata", "fullName", "allureId", "name", "LabelName", "includedInTestPlan", "arr", "indices", "ALLURE_REPORT_SYSTEM_HOOK", "registerMochaEventListeners", "onStart", "onSuite", "reportSuiteEnd", "onHook", "onHookEnd", "onTest", "reportTestPass", "onFail", "reportTestSkip", "reportTestEnd", "injectFlushMessageHooks", "flushRuntimeMessages", "onAfterAll", "initTestRuntime", "reportRunStart", "suite", "applyTestPlan", "reportSuiteStart", "hook", "isAllureHook", "reportHookStart", "reportHookEnd", "test", "isTestReported", "reportTestStart", "testOrHook", "err", "isHook", "isRootAfterAllHook", "reportTestOrHookFail", "completeHookErrorReporting", "completeSpecIfNoAfterHookLeft", "IS_WIN", "getFileNameFromPath", "path", "resolveSpecRelativePath", "spec", "projectDir", "getProjectDir", "specPath", "uint8ArrayToBase64", "data", "getTestStartData", "test", "getTestMetadata", "getTestStopData", "getTestSkipData", "getStepStopData", "step", "status", "statusDetails", "resolveStepStatus", "testReportedKey", "markTestAsReported", "isTestReported", "iterateSuites", "parent", "suiteStack", "s", "i", "iterateTests", "suite", "getSuitePath", "suites", "generateApiStepId", "getAllureState", "getTestMetadata", "test", "rawName", "name", "labels", "links", "extractMetadataFromString", "fullNameSuffix", "isAllureHook", "hook", "ALLURE_REPORT_SYSTEM_HOOK", "isRootAfterAllHook", "isLastRootAfterHook", "context", "currentAfterAll", "h", "getStatusDataOfTestSkippedByHookError", "hookTitle", "isEachHook", "err", "suite", "status", "Status", "getStatusFromError", "message", "trace", "getMessageAndTraceFromError", "getSkipReason", "suiteName", "ALLURE_STEP_CMD_SUBJECT", "isApiStep", "descriptor", "isLogStep", "startAllureApiStep", "name", "reportStepStart", "pushAllureStep", "id", "generateApiStepId", "pushStep", "reportStepError", "error", "status", "getStatusFromError", "statusDetails", "getMessageAndTraceFromError", "stopAllureApiStepStackTip", "associateErrorWithRunningSteps", "stopCurrentAllureApiStep", "findAndStopStepWithSubsteps", "stepDescriptor", "pred", "stopSelectedSteps", "popUntilFindIncluded", "getStepStack", "stopAllSteps", "popAllSteps", "finalizeSteps", "getStepsToFinalize", "finalizeOneStep", "clearStepsToFinalize", "resolveStepStatus", "step", "Status", "finalizer", "data", "enqueueRuntimeMessage", "stepStack", "firstApiStepAfterLastLogStep", "logEntryOrMessage", "propagateErrorToStepDescriptor", "errorOfSubstep", "steps", "stepEntry", "stopStep", "reportStepStop", "setupStepFinalization", "initTestRuntime", "setGlobalTestRuntime", "AllureCypressTestRuntime", "getTestRuntime", "getGlobalTestRuntime", "#resetMessages", "labels", "#enqueueMessageAsync", "links", "name", "value", "options", "markdown", "html", "content", "attachmentRawContent", "actualEncoding", "attachmentContent", "uint8ArrayToBase64", "path", "status", "Status", "error", "ALLURE_STEP_CMD_SUBJECT", "startAllureApiStep", "stopCurrentAllureApiStep", "getMessageAndTraceFromError", "body", "result", "mode", "taskName", "messages", "#dequeueAllMessages", "args", "setRuntimeMessages", "message", "enqueueRuntimeMessage", "getRuntimeMessages", "reportRunStart", "enqueueRuntimeMessage", "reportSuiteStart", "suite", "reportSuiteEnd", "reportHookStart", "hook", "start", "reportHookEnd", "finalizeSteps", "reportTestStart", "test", "setCurrentTest", "getTestStartData", "markTestAsReported", "reportStepStart", "id", "name", "reportStepStop", "step", "status", "statusDetails", "getStepStopData", "reportTestPass", "reportTestOrHookFail", "err", "getStatusFromError", "getMessageAndTraceFromError", "stopAllSteps", "completeHookErrorReporting", "isEachHook", "testFailData", "getStatusDataOfTestSkippedByHookError", "reportCurrentTestIfAny", "reportRemainingTests", "reportTestSkip", "isTestReported", "Status", "getTestSkipData", "reportTestEnd", "dropCurrentTest", "reportScreenshot", "path", "ContentType", "completeSpecIfNoAfterHookLeft", "context", "isLastRootAfterHook", "isAllureHook", "completeSpecAsync", "completeSpecOnAfterHookFailure", "hookError", "allureError", "logAllureRootAfterError", "throwAfterSpecCompletion", "flushRuntimeMessages", "getTestRuntime", "currentTest", "getCurrentTest", "iterateTests", "reportTestsSkippedByHookError", "getTestStopData", "getSuitePath", "s", "enableScopeLevelAfterHookReporting", "suiteDepthCounter", "createSuiteDepthCounterState", "patchDescribe", "patchAfter", "suiteDepth", "incrementSuiteDepth", "decrementSuiteDepth", "patchDescribeFn", "target", "title", "configOrFn", "fn", "forwardDescribeCall", "originalDescribeFn", "patchedDescribe", "getSuiteDepth", "originalAfter", "patchedAfter", "nameOrFn", "wrapRootAfterFn", "args", "wrappedFn", "wrapAfterFnWithCallback", "wrapAfterFnWithoutArgs", "done", "wrappedDone", "hookError", "completeSpecOnAfterHookFailure", "completeSpecIfNoAfterHookLeft", "allureError", "result", "syncError", "e", "throwAfterSpecCompletion", "isPromise", "asyncError", "serialize_default", "value", "isDomObject", "stringifyAsDom", "serialize", "getSerializeOptions", "maxDepth", "maxLength", "getConfig", "nonNullReplacerWithDomSupport", "_", "shouldCreateStepFromCommandLogEntry", "entry", "event", "instrument", "isApiStepErrorLogEntry", "setupScreenshotAttachmentStep", "originalName", "name", "step", "getCurrentStep", "isLogStep", "commandName", "nameFromProps", "startCommandLogStep", "currentLogEntry", "getCurrentLogEntry", "shouldStopCurrentLogStep", "stopCommandLogStep", "pushLogEntry", "reportStepStart", "getCommandLogStepName", "scheduleCommandLogStepStop", "entryId", "findAndStopStepWithSubsteps", "id", "stepDescriptor", "pushStep", "setupStepFinalization", "data", "getCommandLogStepParameters", "groupStart", "end", "originalEndGroup", "originalEnd", "consoleProps", "ALLURE_STEP_CMD_SUBJECT", "message", "displayName", "resolvedName", "resolvedMessage", "maybeGetAssertionLogMessage", "maybeGetCucumberLogMessage", "getLogProps", "k", "v", "serialize_default", "getPropValueSetFilter", "WELL_KNOWN_CUCUMBER_LOG_NAMES", "isAssertionWithMessage", "props", "isDefined", "isAssertLog", "getStepStack", "newLogEntry", "currentEntryIsGroup", "currentEntryType", "newEntryType", "value", "registerCypressEventListeners", "onFail", "onLogAdded", "enableReportingOfCypressScreenshots", "onAfterScreenshot", "originalName", "path", "name", "getFileNameFromPath", "reportScreenshot", "setupScreenshotAttachmentStep", "_", "entry", "shouldCreateStepFromCommandLogEntry", "startCommandLogStep", "error", "reportStepError", "noSubsequentFailListeners", "enableAllure", "registerMochaEventListeners", "registerCypressEventListeners", "injectFlushMessageHooks", "enableScopeLevelAfterHookReporting", "initializeAllure", "isAllureInitialized", "setAllureInitialized", "enableAllure", "enableReportingOfCypressScreenshots", "initializeAllure"]
}
