"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerMochaEventListeners = exports.injectFlushMessageHooks = exports.ALLURE_REPORT_SYSTEM_HOOK = void 0;
var _lifecycle = require("../lifecycle.js");
var _runtime = require("../runtime.js");
var _testplan = require("../testplan.js");
var _utils = require("../utils.js");
var ALLURE_REPORT_SYSTEM_HOOK = exports.ALLURE_REPORT_SYSTEM_HOOK = "__allure_report_system_hook__";
var registerMochaEventListeners = () => {
  Cypress.mocha.getRunner().on("start", onStart).on("suite", onSuite).on("suite end", _lifecycle.reportSuiteEnd).on("hook", onHook).on("hook end", onHookEnd).on("test", onTest).on("pass", _lifecycle.reportTestPass).on("fail", onFail).on("pending", _lifecycle.reportTestSkip).on("test end", _lifecycle.reportTestEnd);
};
exports.registerMochaEventListeners = registerMochaEventListeners;
var injectFlushMessageHooks = () => {
  afterEach(ALLURE_REPORT_SYSTEM_HOOK, _lifecycle.flushRuntimeMessages);
  after(ALLURE_REPORT_SYSTEM_HOOK, onAfterAll);
};
exports.injectFlushMessageHooks = injectFlushMessageHooks;
var onStart = () => {
  (0, _runtime.initTestRuntime)();
  (0, _lifecycle.reportRunStart)();
};
var onSuite = suite => {
  if (suite.root) {
    (0, _testplan.applyTestPlan)(Cypress.spec, suite);
  }
  (0, _lifecycle.reportSuiteStart)(suite);
};
var onHook = hook => {
  if ((0, _utils.isAllureHook)(hook)) {
    return;
  }
  (0, _lifecycle.reportHookStart)(hook);
};
var onHookEnd = hook => {
  if ((0, _utils.isAllureHook)(hook)) {
    return;
  }
  (0, _lifecycle.reportHookEnd)(hook);
};
var onTest = test => {
  // Cypress emits an extra EVENT_TEST_BEGIN if the test is skipped.
  // reportTestSkip does that already, so we need to filter the extra event out.
  if (!(0, _utils.isTestReported)(test)) {
    (0, _lifecycle.reportTestStart)(test);
  }
};
var onFail = (testOrHook, err) => {
  var isHook = ("hookName" in testOrHook);
  if (isHook && (0, _utils.isRootAfterAllHook)(testOrHook)) {
    // Errors in spec-level 'after all' hooks are handled by Allure wrappers.
    return;
  }
  var isAllureHookFailure = isHook && (0, _utils.isAllureHook)(testOrHook);
  if (isAllureHookFailure) {
    var _testOrHook$duration;
    // Normally, Allure hooks are skipped from the report.
    // In case of errors, it will be helpful to see them.
    (0, _lifecycle.reportHookStart)(testOrHook, Date.now() - ((_testOrHook$duration = testOrHook.duration) !== null && _testOrHook$duration !== void 0 ? _testOrHook$duration : 0));
  }

  // This will mark the fixture and the test (if any) as failed/broken.
  (0, _lifecycle.reportTestOrHookFail)(err);
  if (isHook) {
    // This will end the fixture and test (if any) and will report the remaining
    // tests in the hook's suite (the ones that will be skipped by Cypress/Mocha).
    (0, _lifecycle.completeHookErrorReporting)(testOrHook, err);
  }
};
var onAfterAll = function onAfterAll() {
  (0, _lifecycle.flushRuntimeMessages)();
  (0, _lifecycle.completeSpecIfNoAfterHookLeft)(this);
};
//# sourceMappingURL=mocha.js.map