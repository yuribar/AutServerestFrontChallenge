"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopCommandLogStep = exports.startCommandLogStep = exports.shouldCreateStepFromCommandLogEntry = exports.setupScreenshotAttachmentStep = void 0;
var _utils = require("../utils.js");
var _lifecycle = require("./lifecycle.js");
var _serialize = _interopRequireDefault(require("./serialize.js"));
var _state = require("./state.js");
var _steps = require("./steps.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var shouldCreateStepFromCommandLogEntry = entry => {
  var {
    event,
    instrument
  } = entry.attributes;
  if (instrument !== "command") {
    // We are interested in the "TEST BODY" panel only for now.
    // Other instruments are logged in separate panels.
    return false;
  }
  if (event) {
    // Events are tricky to report as they may span across commands and even leave the test's scope.
    // We ignore them for now.
    return false;
  }
  if (isApiStepErrorLogEntry(entry)) {
    // Cypress don't create a log message for 'cy.then' except when it throws an error.
    // This is in particularly happens when the function passed to 'allure.step' throws. In such a case however,
    // creating an extra step from the log entry is redundant because the error is already included in the report as
    // a part of the step.
    return false;
  }
  return true;
};

/**
 * Checks if the current step represents a cy.screenshot command log entry. If this is the case, associates the name
 * of the screenshot with the step. Later, that will allow converting the step with the attachment into the attachment
 * step.
 */
exports.shouldCreateStepFromCommandLogEntry = shouldCreateStepFromCommandLogEntry;
var setupScreenshotAttachmentStep = (originalName, name) => {
  var step = (0, _state.getCurrentStep)();
  if (step && (0, _steps.isLogStep)(step)) {
    var {
      name: commandName,
      props: {
        name: nameFromProps
      }
    } = step.log.attributes.consoleProps();
    if (commandName === "screenshot" && nameFromProps === originalName) {
      step.attachmentName = name;
    }
  }
};
exports.setupScreenshotAttachmentStep = setupScreenshotAttachmentStep;
var startCommandLogStep = entry => {
  var currentLogEntry = getCurrentLogEntry();
  if (typeof currentLogEntry !== "undefined" && shouldStopCurrentLogStep(currentLogEntry.log, entry)) {
    stopCommandLogStep(currentLogEntry.log.attributes.id);
  }
  pushLogEntry(entry);
  (0, _lifecycle.reportStepStart)(entry.attributes.id, getCommandLogStepName(entry));
  scheduleCommandLogStepStop(entry);
};
exports.startCommandLogStep = startCommandLogStep;
var stopCommandLogStep = entryId => (0, _steps.findAndStopStepWithSubsteps)(_ref => {
  var {
    id
  } = _ref;
  return id === entryId;
});
exports.stopCommandLogStep = stopCommandLogStep;
var pushLogEntry = entry => {
  var id = entry.attributes.id;
  var stepDescriptor = {
    id,
    type: "log",
    log: entry
  };
  (0, _state.pushStep)(stepDescriptor);

  // Some properties of some Command Log entries are undefined at the time the entry is stopped. An example is the
  // Yielded property of some queries. We defer converting them to Allure step parameters until the test/hook ends.
  (0, _state.setupStepFinalization)(stepDescriptor, data => {
    data.parameters = getCommandLogStepParameters(entry);
    if (stepDescriptor.attachmentName) {
      // Rename the step to match the attachment name. Once the names are the same, Allure will render the
      // attachment in the place of the step.
      data.name = stepDescriptor.attachmentName;
    }
  });
};
var scheduleCommandLogStepStop = entry => {
  var {
    groupStart,
    end,
    id
  } = entry.attributes;
  if (end) {
    // Some entries are already completed (this is similar to the idea behind allure.logStep).
    // Cypress won't call entry.end() in such a case, so we need to stop such a step now.
    // Example: cy.log
    stopCommandLogStep(id);
  } else if (groupStart) {
    // A logging group must be stopped be the user via the Cypress.Log.endGroup() call.
    // If the call is missing, the corresponding step will be stopped either at the test's (the hook's) end.
    var originalEndGroup = entry.endGroup;
    entry.endGroup = function () {
      stopCommandLogStep(id);
      return originalEndGroup.call(this);
    };
  } else {
    // Regular log entries are finalized by Cypress via the Cypress.Log.end() call. We're hooking into this function
    // to complete the step at the same time.
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var originalEnd = entry.end;
    entry.end = function () {
      stopCommandLogStep(id);
      return originalEnd.call(this);
    };
  }
};
var isApiStepErrorLogEntry = _ref2 => {
  var {
    attributes: {
      name,
      consoleProps
    }
  } = _ref2;
  return name === "then" && Object.is(consoleProps().props["Applied To"], _steps.ALLURE_STEP_CMD_SUBJECT);
};
var getCommandLogStepName = entry => {
  var _ref3, _ref4, _maybeGetAssertionLog;
  var {
    name,
    message,
    displayName
  } = entry.attributes;
  var resolvedName = (displayName !== null && displayName !== void 0 ? displayName : name).trim();
  var resolvedMessage = ((_ref3 = (_ref4 = (_maybeGetAssertionLog = maybeGetAssertionLogMessage(entry)) !== null && _maybeGetAssertionLog !== void 0 ? _maybeGetAssertionLog : maybeGetCucumberLogMessage(entry)) !== null && _ref4 !== void 0 ? _ref4 : entry.attributes.renderProps().message) !== null && _ref3 !== void 0 ? _ref3 : message).trim();
  var stepName = [resolvedName, resolvedMessage].filter(Boolean).join(" ");
  return stepName;
};
var getCommandLogStepParameters = entry => getLogProps(entry).map(_ref5 => {
  var [k, v] = _ref5;
  return {
    name: k.toString(),
    value: (0, _serialize.default)(v)
  };
}).filter(getPropValueSetFilter(entry));
var WELL_KNOWN_CUCUMBER_LOG_NAMES = ["Given", "When", "Then", "And"];
var maybeGetCucumberLogMessage = entry => {
  var {
    attributes: {
      name,
      message
    }
  } = entry;
  if (WELL_KNOWN_CUCUMBER_LOG_NAMES.includes(name.trim()) && message.startsWith("**") && message.endsWith("**")) {
    return message.substring(2, message.length - 2);
  }
};
var getLogProps = entry => {
  var {
    attributes: {
      consoleProps
    }
  } = entry;
  var isAssertionWithMessage = !!maybeGetAssertionLogMessage(entry);
  var {
    props,
    name
  } = consoleProps();

  // accessing LocalStorage after the page reload can stick the test runner
  // to avoid the issue, we just need to log the command manually
  // the problem potentially can happen with other storage related commands, like `clearAllLocalStorage`, `clearAllSessionStorage`, `getAllLocalStorage`, `getAllSessionStorage`, `setLocalStorage`, `setSessionStorage`
  // but probably, we don't need to silent them all at this moment
  // the context: https://github.com/allure-framework/allure-js/issues/1222
  if (["clearLocalStorage"].includes(name)) {
    return [];
  }

  // For assertion logs, we interpolate the 'Message' property, which contains unformatted assertion description,
  // directly into the step's name.
  // No need to keep the exact same information in the step's parameters.
  return Object.entries(props).filter(_ref6 => {
    var [k, v] = _ref6;
    return (0, _utils.isDefined)(v) && !(isAssertionWithMessage && k === "Message");
  });
};
var maybeGetAssertionLogMessage = entry => {
  if (isAssertLog(entry)) {
    var message = entry.attributes.consoleProps().props.Message;
    if (message && typeof message === "string") {
      return message;
    }
  }
};
var isAssertLog = _ref7 => {
  var {
    attributes: {
      name
    }
  } = _ref7;
  return name === "assert";
};
var getCurrentLogEntry = () => (0, _state.getStepStack)().findLast(_steps.isLogStep);
var shouldStopCurrentLogStep = (currentLogEntry, newLogEntry) => {
  var {
    groupStart: currentEntryIsGroup,
    type: currentEntryType
  } = currentLogEntry.attributes;
  var {
    type: newEntryType
  } = newLogEntry.attributes;
  return !currentEntryIsGroup && (currentEntryType === "child" || newEntryType !== "child");
};
var getPropValueSetFilter = entry => entry.attributes.name === "wrap" ? () => true : _ref8 => {
  var {
    name,
    value
  } = _ref8;
  return name !== "Yielded" || value !== "{}";
};
//# sourceMappingURL=commandLog.js.map